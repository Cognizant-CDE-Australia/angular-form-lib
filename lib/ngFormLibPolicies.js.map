{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///lib/ngFormLibPolicies.js","webpack:///webpack/bootstrap a5df63fbd71118df4315?360a","webpack:///external \"angular\"?11d2","webpack:///./modules/ngFormLib/policy/behaviourOnStateChange/PolicyBehaviourOnStateChange.js","webpack:///./modules/ngFormLib/policy/checkForStateChanges/PolicyCheckForStateChanges.js","webpack:///./modules/ngFormLib/policy/defaultPolicies.js","webpack:///./modules/ngFormLib/policy/stateDefinitions/PolicyStateDefinitions.js","webpack:///external \"angular-scroll\""],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_29__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","0","1","18","_interopRequireDefault","obj","__esModule","default","setFocusOnField","$document","$timeout","duration","element","offset","offsetHeight","cancel","timeoutPromise","scrollPromise","focus","scrollToElement","Object","defineProperty","value","_angular","_angular2","mod","name","service","duScrollDuration","behaviourOnErrorFocusFirstField","formController","focusController","_parentController","applyBehaviour","fieldElem","fieldState","formSubmitAttempted","firstElement","$name","querySelectorAll","isFirstElement","_focusErrorElement","_policy","fieldFocusScrollOffset","resetBehaviour","onSubmitFocusFirstFieldIfError","formPolicyBehaviourOnStateChangeLibrary","19","checkForStateChangesOnBlurUntilSubmitThenOnChange","scope","stateDefinitions","ngModelController","errorWatch","$on","noop","watchForErrorChanges","watchForBlurEvent","checkForStateChangesOnChange","checkForStateChangesOnBlur","createWatch","stateName","stateCondition","$watch","hasOwnProperty","evaluateFieldStates","prop","$eval","fieldName","bind","$apply","constant","onChange","onBlur","onBlurUntilSubmitThenOnChange","formPolicyCheckForStateChangesLibrary","20","_PolicyBehaviourOnStateChange","_PolicyBehaviourOnStateChange2","_PolicyCheckForStateChanges","_PolicyCheckForStateChanges2","_PolicyStateDefinitions","_PolicyStateDefinitions2","21","errorOnSubmit","formName","errorOnDirty","errorImmediately","errorOnSubmitAndDirty","errorOnSubmitOrDirty","successOnSubmit","successOnDirty","successImmediately","successOnSubmitAndDirty","successOnSubmitOrDirty","onSubmit","onDirty","immediately","onSubmitAndDirty","onSubmitOrDirty","formPolicyErrorDefinitionLibrary","formPolicySuccessDefinitionLibrary","error","success","29"],"mappings":"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","file":"lib/ngFormLibPolicies.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-scroll\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"angular-scroll\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"angular\"), require(\"angular-scroll\")) : factory(root[\"angular\"], root[\"angular-scroll\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_29__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-scroll\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"angular-scroll\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"angular\"), require(\"angular-scroll\")) : factory(root[\"angular\"], root[\"angular-scroll\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_29__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(20);\n\n\n/***/ },\n\n/***/ 1:\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n\n/***/ 18:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\t__webpack_require__(29);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// The form policy intentionally has no hard dependencies.\n\t// If there are form-policy values that exist when the service is being constructed, it will use them.\n\t// Otherwise it will use no-op policy functions.\n\tvar mod = _angular2.default.module('ngFormLib.policy.behaviourOnStateChange', ['duScroll']);\n\t\n\texports.default = mod.name;\n\t\n\t// Helper functions\n\t\n\tvar timeoutPromise, scrollPromise;\n\t\n\tfunction setFocusOnField($document, $timeout, duration, element, offset) {\n\t  // If no offsetHeight then assume it's invisible and let the next error field take the scroll position\n\t  if (element[0].offsetHeight) {\n\t    //console.log('Error focus set to: ' + domElement.id);\n\t    $timeout.cancel(timeoutPromise);\n\t    $timeout.cancel(scrollPromise); // This doesn't seem to make a difference on a Mac - user-generated scrolling does not get cancelled\n\t    timeoutPromise = $timeout(function () {\n\t      element[0].focus();\n\t    }, duration);\n\t    scrollPromise = $document.scrollToElement(element, offset, duration); // scrollToElement() comes from the angular-scroll directive // No offset\n\t    return true;\n\t  }\n\t  return false; // Indicate that we did NOT set the focus\n\t}\n\t\n\t/**\n\t * Returns a function that can be called when an error is showing FOR THIS FIELD. The function is dynamically created\n\t *  based on the form policy.\n\t *\n\t *  The dynamic function sets the focus if the form policy allows it to\n\t *  The input parameters are:\n\t *    - DOMElement of the current form-field control that could get focus\n\t *    - whether an error is showing on the form-field\n\t *    - whether the form was just attempted to be submitted\n\t *\n\t *  The returned function is stored against the form controller as _applyFormFocusPolicy(...)\n\t *  _applyFormFocusPolicy() should be called by the field-error-controller directive whenever the field state changes,\n\t *   and when a form-submit event occurs.\n\t */\n\tmod.service('formPolicyBehaviourOnStateChangeLibrary', ['$document', '$timeout', 'duScrollDuration', function ($document, $timeout, duScrollDuration) {\n\t\n\t  // Policy implementation functions\n\t  function behaviourOnErrorFocusFirstField(formController) {\n\t    // We want to pretend that there is a single controller for the form, for the purpose of managing the focus.\n\t    // Otherwise, the main form sets the focus, then the subform (ng-form) also sets the focus\n\t    var focusController = formController._parentController || formController;\n\t\n\t    return {\n\t      // This function is called by the fieldErrorController when the fieldState changes and when the form is submitted\n\t      applyBehaviour: function applyBehaviour(fieldElem, fieldState, formSubmitAttempted) {\n\t        // Set the focus to the field if there is an error showing and a form-submit has been attempted\n\t        if (fieldState === 'error' && formSubmitAttempted) {\n\t          // ...and if the focusErrorElement is blank...\n\t          //if (!focusController._focusErrorElement && setFocusOnField($document, $timeout, duScrollDuration, fieldElem, formController._policy.fieldFocusScrollOffset)) {\n\t          //  focusController._focusErrorElement = fieldElem;\n\t          //}\n\t\n\t          // Make sure element is the first field with an error based on DOM order\n\t          var firstElement = $document[0][focusController.$name].querySelectorAll('.ng-invalid')[0];\n\t          var isFirstElement = firstElement ? firstElement.id === fieldElem[0].id : false;\n\t\n\t          // ...and if the focusErrorElement is blank...\n\t          if (!focusController._focusErrorElement && isFirstElement && setFocusOnField($document, $timeout, duScrollDuration, fieldElem, formController._policy.fieldFocusScrollOffset)) {\n\t            focusController._focusErrorElement = fieldElem;\n\t          }\n\t        }\n\t      },\n\t      resetBehaviour: function resetBehaviour() {\n\t        focusController._focusErrorElement = null;\n\t      }\n\t    };\n\t  }\n\t\n\t  return {\n\t    onSubmitFocusFirstFieldIfError: behaviourOnErrorFocusFirstField\n\t  };\n\t}]);\n\t\n\tmod.factory('formPolicyBehaviourOnStateChange', ['formPolicyBehaviourOnStateChangeLibrary', function (formPolicyBehaviourOnStateChangeLibrary) {\n\t  return formPolicyBehaviourOnStateChangeLibrary.onSubmitFocusFirstFieldIfError;\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n\n/***/ 19:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.policy.checkForStateChanges', []);\n\t\n\texports.default = mod.name;\n\t\n\t// Policy implementation functions\n\t\n\tfunction checkForStateChangesOnBlurUntilSubmitThenOnChange(scope, element, name, stateDefinitions, ngModelController) {\n\t  var errorWatch;\n\t\n\t  scope.$on('event:FormSubmitAttempted', function () {\n\t    (errorWatch || _angular2.default.noop)(); // Remove the error watcher, which may-or-may-not be present\n\t    errorWatch = watchForErrorChanges(scope, stateDefinitions, ngModelController);\n\t    //console.log('heard formSubmitAttempted');\n\t  });\n\t\n\t  // Listen for the form reset event and cancel the submit-watcher\n\t  scope.$on('event:FormReset', function () {\n\t    (errorWatch || _angular2.default.noop)(); // Remove the error watcher, which may-or-may-not be present\n\t    //console.log('heard formReset');\n\t  });\n\t\n\t  watchForBlurEvent(scope, element, name, stateDefinitions, ngModelController);\n\t}\n\t\n\tfunction checkForStateChangesOnChange(scope, element, name, stateDefinitions, ngModelController) {\n\t  // Watch the error condition for changes, and flag the field as inErrorShowing when the errorCondition is true\n\t  watchForErrorChanges(scope, stateDefinitions, ngModelController);\n\t}\n\t\n\tfunction checkForStateChangesOnBlur(scope, element, name, stateDefinitions, ngModelController) {\n\t  watchForBlurEvent(scope, element, name, stateDefinitions, ngModelController);\n\t}\n\t\n\t// Helper methods\n\tfunction createWatch(scope, ngModelController, stateName, stateCondition) {\n\t  scope.$watch(stateCondition, function (value) {\n\t    if (value === true) {\n\t      ngModelController.fieldState = stateName; // THIS IS THE KEY FLAG\n\t      //console.log('A: ' + stateCondition + ' = ' + value);\n\t    }\n\t  });\n\t}\n\t\n\tfunction watchForErrorChanges(scope, stateDefinitions, ngModelController) {\n\t  // Set up a watch for each state definition... expensive?\n\t  for (var stateName in stateDefinitions) {\n\t    if (stateDefinitions.hasOwnProperty(stateName)) {\n\t      createWatch(scope, ngModelController, stateName, stateDefinitions[stateName]);\n\t    }\n\t  }\n\t}\n\t\n\tfunction evaluateFieldStates(scope, stateDefinitions, ngModelController) {\n\t  for (var prop in stateDefinitions) {\n\t    if (scope.$eval(stateDefinitions[prop]) === true) {\n\t      ngModelController.fieldState = prop;\n\t      //console.log('B: ' + stateDefinitions[prop] + ' = ' + prop);\n\t      break;\n\t    }\n\t  }\n\t}\n\t\n\tfunction watchForBlurEvent(scope, element, fieldName, stateDefinitions, ngModelController) {\n\t  // Determine the initial field state. First state to evaluate to TRUE wins\n\t  evaluateFieldStates(scope, stateDefinitions, ngModelController);\n\t\n\t  element.bind('blur', function ngShowWatchAction() {\n\t    evaluateFieldStates(scope, stateDefinitions, ngModelController);\n\t    scope.$apply(); // We are in a jQueryLite handler and have changed a scope property - fire the watchers!\n\t  });\n\t}\n\t\n\t// Define the different display trigger implementations available\n\tmod.constant('formPolicyCheckForStateChangesLibrary', function () {\n\t  return {\n\t    onChange: checkForStateChangesOnChange,\n\t    onBlur: checkForStateChangesOnBlur,\n\t    onBlurUntilSubmitThenOnChange: checkForStateChangesOnBlurUntilSubmitThenOnChange\n\t  };\n\t}());\n\t\n\t// This 'service' is the default implementation of the check-for-errors policy\n\tmod.factory('formPolicyCheckForStateChanges', ['formPolicyCheckForStateChangesLibrary', function (formPolicyCheckForStateChangesLibrary) {\n\t  return formPolicyCheckForStateChangesLibrary.onBlurUntilSubmitThenOnChange;\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n\n/***/ 20:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _PolicyBehaviourOnStateChange = __webpack_require__(18);\n\t\n\tvar _PolicyBehaviourOnStateChange2 = _interopRequireDefault(_PolicyBehaviourOnStateChange);\n\t\n\tvar _PolicyCheckForStateChanges = __webpack_require__(19);\n\t\n\tvar _PolicyCheckForStateChanges2 = _interopRequireDefault(_PolicyCheckForStateChanges);\n\t\n\tvar _PolicyStateDefinitions = __webpack_require__(21);\n\t\n\tvar _PolicyStateDefinitions2 = _interopRequireDefault(_PolicyStateDefinitions);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.defaultPolicies', [_PolicyBehaviourOnStateChange2.default, _PolicyCheckForStateChanges2.default, _PolicyStateDefinitions2.default]);\n\t\n\texports.default = mod.name;\n\tmodule.exports = exports['default'];\n\n/***/ },\n\n/***/ 21:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Define the different display trigger implementations available\n\tvar mod = _angular2.default.module('ngFormLib.policy.stateDefinitions', []);\n\t\n\texports.default = mod.name;\n\t\n\t// Error Conditions\n\t\n\tfunction errorOnSubmit(formName, fieldName) {\n\t  return formName + '._formSubmitAttempted && ' + fieldName + '.$invalid';\n\t}\n\t\n\tfunction errorOnDirty(formName, fieldName) {\n\t  return fieldName + '.$dirty && ' + fieldName + '.$invalid';\n\t}\n\t\n\tfunction errorImmediately(formName, fieldName) {\n\t  return fieldName + '.$invalid';\n\t}\n\t\n\tfunction errorOnSubmitAndDirty(formName, fieldName) {\n\t  return formName + '._formSubmitAttempted && ' + fieldName + '.$dirty && ' + fieldName + '.$invalid';\n\t}\n\t\n\tfunction errorOnSubmitOrDirty(formName, fieldName) {\n\t  return '(' + formName + '._formSubmitAttempted || ' + fieldName + '.$dirty) && ' + fieldName + '.$invalid';\n\t}\n\t\n\tmod.value('formPolicyErrorDefinitionLibrary', function () {\n\t  return {\n\t    onSubmit: errorOnSubmit,\n\t    onDirty: errorOnDirty,\n\t    immediately: errorImmediately,\n\t    onSubmitAndDirty: errorOnSubmitAndDirty,\n\t    onSubmitOrDirty: errorOnSubmitOrDirty\n\t  };\n\t}());\n\t\n\t// Success Definitions\n\tfunction successOnSubmit(formName, fieldName) {\n\t  return formName + '._formSubmitAttempted && ' + fieldName + '.$valid';\n\t}\n\t\n\tfunction successOnDirty(formName, fieldName) {\n\t  return fieldName + '.$dirty && ' + fieldName + '.$valid';\n\t}\n\t\n\tfunction successImmediately(formName, fieldName) {\n\t  return fieldName + '.$valid';\n\t}\n\t\n\tfunction successOnSubmitAndDirty(formName, fieldName) {\n\t  return formName + '._formSubmitAttempted && ' + fieldName + '.$dirty && ' + fieldName + '.$valid';\n\t}\n\t\n\tfunction successOnSubmitOrDirty(formName, fieldName) {\n\t  return '(' + formName + '._formSubmitAttempted || ' + fieldName + '.$dirty) && ' + fieldName + '.$valid';\n\t}\n\t\n\tmod.value('formPolicySuccessDefinitionLibrary', function () {\n\t  return {\n\t    onSubmit: successOnSubmit,\n\t    onDirty: successOnDirty,\n\t    immediately: successImmediately,\n\t    onSubmitAndDirty: successOnSubmitAndDirty,\n\t    onSubmitOrDirty: successOnSubmitOrDirty\n\t  };\n\t}());\n\t\n\t// This 'service' is the default implementation of the check-for-errors policy\n\tmod.factory('formPolicyStateDefinitions', ['formPolicyErrorDefinitionLibrary', 'formPolicySuccessDefinitionLibrary', function (formPolicyErrorDefinitionLibrary, formPolicySuccessDefinitionLibrary) {\n\t\n\t  // The FieldErrorController will ask for the stateDefinitions, passing the formName and fieldName as parameters\n\t  return function (formName, fieldName) {\n\t    // Return an object with the stateName(key) and the stateDefinition string(value)\n\t    return {\n\t      'error': formPolicyErrorDefinitionLibrary.onSubmitOrDirty(formName, fieldName),\n\t      'success': formPolicySuccessDefinitionLibrary.onSubmitOrDirty(formName, fieldName)\n\t    };\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n\n/***/ 29:\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_29__;\n\n/***/ }\n\n/******/ })\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** lib/ngFormLibPolicies.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a5df63fbd71118df4315\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 1\n ** module chunks = 0 1\n **/","import angular from 'angular';\nimport 'angular-scroll';\n\n// The form policy intentionally has no hard dependencies.\n// If there are form-policy values that exist when the service is being constructed, it will use them.\n// Otherwise it will use no-op policy functions.\nconst mod = angular.module('ngFormLib.policy.behaviourOnStateChange', ['duScroll']);\n\nexport default mod.name;\n\n\n// Helper functions\nvar timeoutPromise, scrollPromise;\n\nfunction setFocusOnField($document, $timeout, duration, element, offset) {\n  // If no offsetHeight then assume it's invisible and let the next error field take the scroll position\n  if (element[0].offsetHeight) {\n    //console.log('Error focus set to: ' + domElement.id);\n    $timeout.cancel(timeoutPromise);\n    $timeout.cancel(scrollPromise);   // This doesn't seem to make a difference on a Mac - user-generated scrolling does not get cancelled\n    timeoutPromise = $timeout(function() { element[0].focus();}, duration);\n    scrollPromise = $document.scrollToElement(element, offset, duration);  // scrollToElement() comes from the angular-scroll directive // No offset\n    return true;\n  }\n  return false; // Indicate that we did NOT set the focus\n}\n\n\n\n/**\n * Returns a function that can be called when an error is showing FOR THIS FIELD. The function is dynamically created\n *  based on the form policy.\n *\n *  The dynamic function sets the focus if the form policy allows it to\n *  The input parameters are:\n *    - DOMElement of the current form-field control that could get focus\n *    - whether an error is showing on the form-field\n *    - whether the form was just attempted to be submitted\n *\n *  The returned function is stored against the form controller as _applyFormFocusPolicy(...)\n *  _applyFormFocusPolicy() should be called by the field-error-controller directive whenever the field state changes,\n *   and when a form-submit event occurs.\n */\nmod.service('formPolicyBehaviourOnStateChangeLibrary', ['$document', '$timeout', 'duScrollDuration',\n  function($document, $timeout, duScrollDuration) {\n\n    // Policy implementation functions\n    function behaviourOnErrorFocusFirstField(formController) {\n      // We want to pretend that there is a single controller for the form, for the purpose of managing the focus.\n      // Otherwise, the main form sets the focus, then the subform (ng-form) also sets the focus\n      var focusController = formController._parentController || formController;\n\n      return {\n        // This function is called by the fieldErrorController when the fieldState changes and when the form is submitted\n        applyBehaviour: function(fieldElem, fieldState, formSubmitAttempted) {\n          // Set the focus to the field if there is an error showing and a form-submit has been attempted\n          if (fieldState === 'error' && formSubmitAttempted) {\n            // ...and if the focusErrorElement is blank...\n            //if (!focusController._focusErrorElement && setFocusOnField($document, $timeout, duScrollDuration, fieldElem, formController._policy.fieldFocusScrollOffset)) {\n            //  focusController._focusErrorElement = fieldElem;\n            //}\n\n            // Make sure element is the first field with an error based on DOM order\n            var firstElement = $document[0][focusController.$name].querySelectorAll('.ng-invalid')[0];\n            var isFirstElement = firstElement ? (firstElement.id === fieldElem[0].id) : false;\n\n            // ...and if the focusErrorElement is blank...\n            if (!focusController._focusErrorElement && isFirstElement && setFocusOnField($document, $timeout, duScrollDuration, fieldElem, formController._policy.fieldFocusScrollOffset)) {\n              focusController._focusErrorElement = fieldElem;\n            }\n          }\n        },\n        resetBehaviour: function() {\n          focusController._focusErrorElement = null;\n        }\n      };\n    }\n\n    return {\n      onSubmitFocusFirstFieldIfError: behaviourOnErrorFocusFirstField\n    };\n  }\n]);\n\nmod.factory('formPolicyBehaviourOnStateChange', ['formPolicyBehaviourOnStateChangeLibrary', function(formPolicyBehaviourOnStateChangeLibrary) {\n  return formPolicyBehaviourOnStateChangeLibrary.onSubmitFocusFirstFieldIfError;\n}]);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/policy/behaviourOnStateChange/PolicyBehaviourOnStateChange.js\n **/","import angular from 'angular';\n\nconst mod = angular.module('ngFormLib.policy.checkForStateChanges', []);\n\nexport default mod.name;\n\n\n// Policy implementation functions\nfunction checkForStateChangesOnBlurUntilSubmitThenOnChange(scope, element, name, stateDefinitions, ngModelController) {\n  var errorWatch;\n\n  scope.$on('event:FormSubmitAttempted', function() {\n    (errorWatch || angular.noop)(); // Remove the error watcher, which may-or-may-not be present\n    errorWatch = watchForErrorChanges(scope, stateDefinitions, ngModelController);\n    //console.log('heard formSubmitAttempted');\n  });\n\n\n  // Listen for the form reset event and cancel the submit-watcher\n  scope.$on('event:FormReset', function() {\n    (errorWatch || angular.noop)(); // Remove the error watcher, which may-or-may-not be present\n    //console.log('heard formReset');\n  });\n\n  watchForBlurEvent(scope, element, name, stateDefinitions, ngModelController);\n}\n\n\nfunction checkForStateChangesOnChange(scope, element, name, stateDefinitions, ngModelController) {\n  // Watch the error condition for changes, and flag the field as inErrorShowing when the errorCondition is true\n  watchForErrorChanges(scope, stateDefinitions, ngModelController);\n}\n\nfunction checkForStateChangesOnBlur(scope, element, name, stateDefinitions, ngModelController) {\n  watchForBlurEvent(scope, element, name, stateDefinitions, ngModelController);\n}\n\n\n// Helper methods\nfunction createWatch(scope, ngModelController, stateName, stateCondition) {\n  scope.$watch(stateCondition, function(value) {\n    if (value === true) {\n      ngModelController.fieldState = stateName;       // THIS IS THE KEY FLAG\n      //console.log('A: ' + stateCondition + ' = ' + value);\n    }\n  });\n}\n\nfunction watchForErrorChanges(scope, stateDefinitions, ngModelController) {\n  // Set up a watch for each state definition... expensive?\n  for (var stateName in stateDefinitions) {\n    if (stateDefinitions.hasOwnProperty(stateName)) {\n      createWatch(scope, ngModelController, stateName, stateDefinitions[stateName]);\n    }\n  }\n}\n\nfunction evaluateFieldStates(scope, stateDefinitions, ngModelController) {\n  for (var prop in stateDefinitions) {\n    if (scope.$eval(stateDefinitions[prop]) === true) {\n      ngModelController.fieldState = prop;\n      //console.log('B: ' + stateDefinitions[prop] + ' = ' + prop);\n      break;\n    }\n  }\n}\n\nfunction watchForBlurEvent(scope, element, fieldName, stateDefinitions, ngModelController) {\n  // Determine the initial field state. First state to evaluate to TRUE wins\n  evaluateFieldStates(scope, stateDefinitions, ngModelController);\n\n  element.bind('blur', function ngShowWatchAction() {\n    evaluateFieldStates(scope, stateDefinitions, ngModelController);\n    scope.$apply(); // We are in a jQueryLite handler and have changed a scope property - fire the watchers!\n  });\n}\n\n// Define the different display trigger implementations available\nmod.constant('formPolicyCheckForStateChangesLibrary', (function() {\n  return {\n    onChange: checkForStateChangesOnChange,\n    onBlur: checkForStateChangesOnBlur,\n    onBlurUntilSubmitThenOnChange: checkForStateChangesOnBlurUntilSubmitThenOnChange\n  };\n})());\n\n  // This 'service' is the default implementation of the check-for-errors policy\nmod.factory('formPolicyCheckForStateChanges', ['formPolicyCheckForStateChangesLibrary', function(formPolicyCheckForStateChangesLibrary) {\n  return formPolicyCheckForStateChangesLibrary.onBlurUntilSubmitThenOnChange;\n}]);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/policy/checkForStateChanges/PolicyCheckForStateChanges.js\n **/","import angular from 'angular';\nimport defaultStateChangeBehaviour from './behaviourOnStateChange/PolicyBehaviourOnStateChange';\nimport defaultStateChangeChecks from './checkForStateChanges/PolicyCheckForStateChanges';\nimport defaultStateDefinitions from './stateDefinitions/PolicyStateDefinitions';\n\nconst mod = angular.module('ngFormLib.defaultPolicies', [\n  defaultStateChangeBehaviour,\n  defaultStateChangeChecks,\n  defaultStateDefinitions\n]);\n\nexport default mod.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/policy/defaultPolicies.js\n **/","import angular from 'angular';\n\n// Define the different display trigger implementations available\nconst mod = angular.module('ngFormLib.policy.stateDefinitions', []);\n\nexport default mod.name\n\n// Error Conditions\nfunction errorOnSubmit(formName, fieldName) {\n  return formName + '._formSubmitAttempted && ' + fieldName + '.$invalid';\n}\n\nfunction errorOnDirty(formName, fieldName) {\n  return fieldName + '.$dirty && ' + fieldName + '.$invalid';\n}\n\nfunction errorImmediately(formName, fieldName) {\n  return fieldName + '.$invalid';\n}\n\nfunction errorOnSubmitAndDirty(formName, fieldName) {\n  return formName + '._formSubmitAttempted && ' + fieldName + '.$dirty && ' + fieldName + '.$invalid';\n}\n\nfunction errorOnSubmitOrDirty(formName, fieldName) {\n  return '(' + formName + '._formSubmitAttempted || ' + fieldName + '.$dirty) && ' + fieldName + '.$invalid';\n}\n\nmod.value('formPolicyErrorDefinitionLibrary', (function() {\n  return {\n    onSubmit: errorOnSubmit,\n    onDirty: errorOnDirty,\n    immediately: errorImmediately,\n    onSubmitAndDirty: errorOnSubmitAndDirty,\n    onSubmitOrDirty: errorOnSubmitOrDirty\n  };\n})());\n\n\n// Success Definitions\nfunction successOnSubmit(formName, fieldName) {\n  return formName + '._formSubmitAttempted && ' + fieldName + '.$valid';\n}\n\nfunction successOnDirty(formName, fieldName) {\n  return fieldName + '.$dirty && ' + fieldName + '.$valid';\n}\n\nfunction successImmediately(formName, fieldName) {\n  return fieldName + '.$valid';\n}\n\nfunction successOnSubmitAndDirty(formName, fieldName) {\n  return formName + '._formSubmitAttempted && ' + fieldName + '.$dirty && ' + fieldName + '.$valid';\n}\n\nfunction successOnSubmitOrDirty(formName, fieldName) {\n  return '(' + formName + '._formSubmitAttempted || ' + fieldName + '.$dirty) && ' + fieldName + '.$valid';\n}\n\nmod.value('formPolicySuccessDefinitionLibrary', (function() {\n  return {\n    onSubmit: successOnSubmit,\n    onDirty: successOnDirty,\n    immediately: successImmediately,\n    onSubmitAndDirty: successOnSubmitAndDirty,\n    onSubmitOrDirty: successOnSubmitOrDirty\n  };\n})());\n\n// This 'service' is the default implementation of the check-for-errors policy\nmod.factory('formPolicyStateDefinitions', ['formPolicyErrorDefinitionLibrary', 'formPolicySuccessDefinitionLibrary',\n  function(formPolicyErrorDefinitionLibrary, formPolicySuccessDefinitionLibrary) {\n\n    // The FieldErrorController will ask for the stateDefinitions, passing the formName and fieldName as parameters\n    return function(formName, fieldName) {\n      // Return an object with the stateName(key) and the stateDefinition string(value)\n      return {\n        'error': formPolicyErrorDefinitionLibrary.onSubmitOrDirty(formName, fieldName),\n        'success': formPolicySuccessDefinitionLibrary.onSubmitOrDirty(formName, fieldName)\n      };\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/policy/stateDefinitions/PolicyStateDefinitions.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_29__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular-scroll\"\n ** module id = 29\n ** module chunks = 1\n **/"],"sourceRoot":""}