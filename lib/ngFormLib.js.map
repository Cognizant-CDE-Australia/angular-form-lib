{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lib/ngFormLib.js","webpack:///webpack/bootstrap a5df63fbd71118df4315","webpack:///external \"angular\"","webpack:///./modules/ngFormLib/controls/errorMessageContainer/ErrorMessageContainer.js","webpack:///./modules/ngFormLib/controls/common/index.js","webpack:///./modules/ngFormLib/controls/common/FormControlService.js","webpack:///./modules/common/Utility.js","webpack:///./modules/ngFormLib/controls/common/FieldErrorController.js","webpack:///./modules/ngFormLib/controls/formCheckbox/FormCheckbox.js","webpack:///./modules/ngFormLib/controls/formDate/FormDate.js","webpack:///./modules/ngFormLib/controls/formInput/FormInput.js","webpack:///./modules/ngFormLib/controls/formRadioButton/FormRadioButton.js","webpack:///./modules/ngFormLib/controls/formReset/FormReset.js","webpack:///./modules/ngFormLib/controls/formSelect/FormSelect.js","webpack:///./modules/ngFormLib/controls/formSubmit/FormSubmit.js","webpack:///./modules/ngFormLib/controls/index.js","webpack:///./modules/ngFormLib/controls/requiredMarker/RequiredMarker.js","webpack:///./modules/ngFormLib/index.js","webpack:///./modules/ngFormLib/policy/FormPolicy.js","webpack:///./modules/ngFormLib/controls/formCheckbox/template/FormCheckboxTemplate.tpl.html","webpack:///./modules/ngFormLib/controls/formDate/template/FormDateInputTemplate.tpl.html","webpack:///./modules/ngFormLib/controls/formInput/template/FormInputTemplate.tpl.html","webpack:///./modules/ngFormLib/controls/formRadioButton/template/FormRadioButtonTemplate.tpl.html","webpack:///./modules/ngFormLib/controls/formSelect/template/FormSelectTemplate.tpl.html","webpack:///./modules/ngFormLib/controls/requiredMarker/template/RequiredMarkerTemplate.tpl.html","webpack:///external \"angular-animate\"","webpack:///external \"angular-translate\""],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_28__","__WEBPACK_EXTERNAL_MODULE_30__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_angular","_angular2","_angularTranslate","_angularTranslate2","mod","name","directive","$compile","$filter","translateError","errorMessage","fieldLabel","firstLetterIsAVowel","indexOf","toLowerCase","undefined","pronoun","ErrorController","element","errors","ariaElement","addError","errorType","removeError","refreshErrorText","str","type","hasOwnProperty","text","generateErrorTag","errorText","toggleErrorVisibilityOnError","controller","formController","scope","watchExpr","_scope","$watch","newValue","val","append","removeErrorMessage","toggleErrorVisibilityForTextError","errorController","fieldController","$setValidity","setSubmitted","$viewChangeListeners","push","$eval","divs","find","len","length","eq","hasClass","remove","restrict","template","replace","link","attr","controllers","fieldName","formName","$name","formField","fieldErrors","textErrors","error","errorShowCondition","fieldWatcher","item","removeAttr","_FieldErrorController","_FieldErrorController2","_FormControlService","_FormControlService2","_RequiredMarker","_RequiredMarker2","_Utility","_Utility2","config","$provide","decorator","$delegate","ngModel","attrs","$injector","$interpolate","get","$set","invoke","$scope","$element","$attrs","form","ngForm","provider","self","counter","defaults","idPrefix","templates","formCheckbox","formDate","formInput","formRadioButton","formSelect","requiredMarker","$get","StringUtil","service","buildDirective","params","transclude","compile","tElement","tAttr","validateComponentStructure","controlName","expectedTemplateElements","expectedAttributes","uid","getUniqueFieldId","inputElem","inputElementName","labelElem","required","getRequiredAttribute","decorateLabel","labelClass","hideLabel","hideRequiredIndicator","labelSuffix","decorateInputField","configFn","templateUrl","getHTMLTemplate","parentFormClasses","inheritedData","split","result","addToAttribute","attributeName","existingVal","removeFromAttribute","trim","hideLabelExpr","addClass","hostElement","inputType","replaceWith","$attr","origAttrName","substr","createErrorFeatures","parentElement","inputElement","fieldLabelStr","errorContainerElem","createFieldHint","fieldHint","fieldHintId","fieldHintDisplay","hintElement","buildNgClassExpression","targetElem","modelStr","checkedStr","disabledStr","ngValue","ngTrueValue","componentName","requiredElements","requiredAttributes","Error","j","constant","convertDate","dateStr","newSep","oldSep","parts","isNaN","join","formatDay","dayOrDate","month","year","dd","mm","yyyy","getUTCDay","getDate","getMonth","getFullYear","dateAdd","numDays","myDate","setDate","getToday","optionalDate","Date","isISODate","monthsBetween","date1","date2","trimRegExp","isDigitsRegExp","isDigits","test","getUniqueId","getTime","Math","random","toArray","arr","key","sort","b","formControlService","$timeout","updateAriaFeatures","fieldState","errorElemId","updateElementStyle","formPolicy","fieldErrorClass","fieldSuccessClass","setupCanShowErrorPropertyOnNgModelController","ngModelController","_policy","stateConditions","stateDefinitions","checkForStateChanges","formGroupElement","errorBehaviour","_applyFormBehaviourOnStateChangePolicy","applyBehaviour","$on","_index","_index2","_ErrorMessageContainer","_ErrorMessageContainer2","checkboxDiv","_common","_common2","prepend","label","parent","DateUtil","dateRegEx","priority","elem","ctrl","$parsers","unshift","viewValue","dateFormatValid","fieldDate","minDate","maxDate","dateChange","$valid","addPlaceholder","placeholderText","addInputGroup","inputGroupPrefix","inputGroupSuffix","wrap","wrapper","placeholder","hasInputGroup","inputPrefix","inputSuffix","parentElemForErrors","rbDiv","$parse","resetFieldState","controlMap","controlList","jLen","control","ngModelGet","formReset","ngModelSet","assign","originalData","copy","on","_controls","$setPristine","$emit","$digest","selectElem","fn","formSubmit","noop","isForm","tagName","bind","event","$apply","$event","preventDefault","_FormCheckbox","_FormCheckbox2","_FormDate","_FormDate2","_FormInput","_FormInput2","_FormRadioButton","_FormRadioButton2","_FormReset","_FormReset2","_FormSelect","_FormSelect2","_FormSubmit","_FormSubmit2","hide","_angularAnimate","_angularAnimate2","_FormPolicy","_FormPolicy2","_controls2","formDirective","formPolicyService","data","pre","extend","getCurrentPolicy","_parentController","behaviourOnStateChange","tellNoOne","formSubmitAttemptedClass","_formSubmitAttempted","resetBehaviour","$broadcast","nullBehaviourOnStateChange","nullStateChanges","fieldFocusScrollOffset","getService","e","policyService","inputElements","forEach","hookupElementToNameToElementMap","map","elementId","splice","rootFormController"],"mappings":"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","file":"lib/ngFormLib.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-animate\"), require(\"angular-translate\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"angular-animate\", \"angular-translate\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"angular\"), require(\"angular-animate\"), require(\"angular-translate\")) : factory(root[\"angular\"], root[\"angular-animate\"], root[\"angular-translate\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_28__, __WEBPACK_EXTERNAL_MODULE_30__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-animate\"), require(\"angular-translate\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"angular-animate\", \"angular-translate\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"angular\"), require(\"angular-animate\"), require(\"angular-translate\")) : factory(root[\"angular\"], root[\"angular-animate\"], root[\"angular-translate\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_28__, __WEBPACK_EXTERNAL_MODULE_30__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(16);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularTranslate = __webpack_require__(30);\n\t\n\tvar _angularTranslate2 = _interopRequireDefault(_angularTranslate);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.errorMessageContainer', [_angularTranslate2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t//angular.module('ngFormLib.controls.errorMessageContainer', ['pascalprecht.translate'])\n\t\n\t/**\n\t * This directive is really a FIELD error message container - it is designed to work with fields exclusively\n\t */\n\t\n\tmod.directive('errorContainer', ['$compile', '$filter', function ($compile, $filter) {\n\t\n\t  function translateError(errorMessage, fieldLabel) {\n\t    var firstLetterIsAVowel = fieldLabel ? 'aeiou'.indexOf(fieldLabel[0].toLowerCase()) !== -1 : undefined;\n\t    return $filter('translate')(errorMessage, { pronoun: firstLetterIsAVowel ? 'an' : 'a', fieldLabel: fieldLabel });\n\t  }\n\t\n\t  function ErrorController(element) {\n\t    var errors = [],\n\t        ariaElement = element;\n\t\n\t    return {\n\t      addError: function addError(errorType, errorMessage, fieldLabel) {\n\t        errors[errorType] = translateError(errorMessage, fieldLabel);\n\t      },\n\t\n\t      removeError: function removeError(errorType) {\n\t        delete errors[errorType];\n\t      },\n\t\n\t      refreshErrorText: function refreshErrorText() {\n\t        var str = '',\n\t            i = 0;\n\t        for (var type in errors) {\n\t          if (errors.hasOwnProperty(type)) {\n\t            str += 'Error ' + ++i + ', ' + errors[type] + ',';\n\t          }\n\t        }\n\t\n\t        if (i === 1) {\n\t          str = '. There is 1 error for this field. ' + str;\n\t        } else if (i > 1) {\n\t          str = '. There are ' + i + ' errors for this field. ' + str;\n\t        }\n\t        ariaElement.text(str);\n\t      }\n\t    };\n\t  }\n\t\n\t  function generateErrorTag(errorType, errorText, fieldLabel) {\n\t    return '<div class=\"text-error ec2-' + errorType + '\"><span class=\"text-error-wrap\">' + translateError(errorText, fieldLabel) + '</span></div>';\n\t  }\n\t\n\t  /**\n\t   * Handle the field-based error messages\n\t   */\n\t  function toggleErrorVisibilityOnError(controller, formController, scope, element, watchExpr, errorType, errorText, fieldLabel) {\n\t    //console.log('watchExpr = ' + watchExpr);\n\t    formController._scope.$watch(watchExpr, function (newValue) {\n\t      if (newValue) {\n\t        // The error text could contain an interpolation string, so we need to compile it\n\t        var val = $compile(generateErrorTag(errorType, errorText, fieldLabel))(scope);\n\t        element.append(val);\n\t        controller.addError(errorType, errorText, fieldLabel);\n\t      } else {\n\t        removeErrorMessage(controller, formController, element, errorType);\n\t      }\n\t      controller.refreshErrorText();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Handle text errors. Text errors are associated with a scope, rather than with a field.\n\t   * This means we can clear them from the scope when the field-they-are-associated-with is changed.\n\t   */\n\t  function toggleErrorVisibilityForTextError(errorController, formController, fieldController, scope, element, watchExpr, fieldLabel) {\n\t    //console.log('Watching error: ' + watchExpr);\n\t\n\t    formController._scope.$watch(watchExpr, function (newValue) {\n\t      // Update the validity of the field's \"watchExpr\" error-key to match the value of the errorText\n\t      fieldController.$setValidity(watchExpr, !newValue);\n\t\n\t      // Remove the old error message for this same errorType first, in cases where the error message is changing.\n\t      removeErrorMessage(errorController, formController, element, watchExpr);\n\t\n\t      if (newValue) {\n\t        // No need to compile the error message as we already have its value\n\t        element.append(generateErrorTag(watchExpr, newValue, fieldLabel));\n\t        errorController.addError(watchExpr, newValue, fieldLabel);\n\t\n\t        // Turn the border red by sending a 'form-submit-attempted' event\n\t        formController.setSubmitted(true);\n\t      }\n\t      errorController.refreshErrorText();\n\t    });\n\t\n\t    // When the field changes, clear the errorText value\n\t    fieldController.$viewChangeListeners.push(function () {\n\t      if (scope.$eval(watchExpr)) {\n\t        scope.$eval(watchExpr + ' = null');\n\t      }\n\t    });\n\t  }\n\t\n\t  function removeErrorMessage(controller, formController, element, errorType) {\n\t    // find the div with our special class, then remove it\n\t    var divs = element.find('div');\n\t    for (var len = divs.length, i = len - 1; i > -1; i--) {\n\t      if (divs.eq(i).hasClass('ec2-' + errorType)) {\n\t        divs.eq(i).remove();\n\t      }\n\t    }\n\t    controller.removeError(errorType);\n\t  }\n\t\n\t  return {\n\t    restrict: 'AE',\n\t    require: ['^form'], // Require the formController controller somewhere in the parent hierarchy (mandatory for field-errors)\n\t    template: '<div class=\"container-error\"></div>',\n\t    replace: true,\n\t    link: function link(scope, element, attr, controllers) {\n\t\n\t      var fieldName = attr.fieldName,\n\t          fieldLabel = attr.fieldLabel || '',\n\t          formController = controllers[0],\n\t          formName = formController.$name,\n\t          formField = formName + '.' + fieldName,\n\t          fieldErrors = scope.$eval(attr.fieldErrors || []),\n\t          // You can escape interpolation brackets inside strings by doing  \\{\\{   - wow!\n\t      textErrors = scope.$eval(attr.textErrors || []);\n\t\n\t      element.attr('id', formName + '-' + fieldName + '-errors');\n\t      element.append('<span class=\"sr-only\" aria-hidden=\"true\" id=\"' + formName + '-' + fieldName + '-errors-aria\"></span>');\n\t\n\t      var ariaElement = element.find('span'),\n\t          errorController = new ErrorController(ariaElement); // new? Maybe make this the directive's controller instead\n\t\n\t      for (var error in fieldErrors) {\n\t        if (fieldErrors.hasOwnProperty(error)) {\n\t          var errorShowCondition = formField + '.fieldState === \"error\" && ' + formField + '.$error.' + error;\n\t          toggleErrorVisibilityOnError(errorController, formController, scope, element, errorShowCondition, error, fieldErrors[error], fieldLabel);\n\t        }\n\t      }\n\t\n\t      // Watch formController[fieldName] - it may not have loaded yet. When it loads, call the main function.\n\t      if (textErrors) {\n\t        //console.log('textErrors: ' + textErrors + ', fieldName = ' + fieldName);\n\t        var fieldWatcher = scope.$watch(function () {\n\t          return formController[fieldName];\n\t        }, function (newValue) {\n\t          if (newValue) {\n\t            fieldWatcher(); // Cancel the watcher\n\t\n\t            // Do the actual thing you planned to do...\n\t            for (var item in textErrors) {\n\t              if (textErrors.hasOwnProperty(item)) {\n\t                toggleErrorVisibilityForTextError(errorController, formController, formController[fieldName], scope, element, textErrors[item], fieldLabel);\n\t              }\n\t            }\n\t          }\n\t        });\n\t      }\n\t\n\t      element.removeAttr('error-container').removeAttr('field-name').removeAttr('field-errors').removeAttr('text-errors');\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _FieldErrorController = __webpack_require__(6);\n\t\n\tvar _FieldErrorController2 = _interopRequireDefault(_FieldErrorController);\n\t\n\tvar _FormControlService = __webpack_require__(4);\n\t\n\tvar _FormControlService2 = _interopRequireDefault(_FormControlService);\n\t\n\tvar _RequiredMarker = __webpack_require__(15);\n\t\n\tvar _RequiredMarker2 = _interopRequireDefault(_RequiredMarker);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.common', [_FieldErrorController2.default, _FormControlService2.default, _RequiredMarker2.default]);\n\t\n\texports.default = mod.name;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _Utility = __webpack_require__(5);\n\t\n\tvar _Utility2 = _interopRequireDefault(_Utility);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.common.formControlService', [_Utility2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// Workaround for bug #1404\n\t// https://github.com/angular/angular.js/issues/1404\n\t// Source: http://plnkr.co/edit/hSMzWC?p=preview\n\t// Not so great for IE8, but necessary for using radio buttons inside of dynamic forms (ng-repeat)\n\t\n\tmod.config(['$provide', function ($provide) {\n\t  $provide.decorator('ngModelDirective', ['$delegate', function ($delegate) {\n\t    var ngModel = $delegate[0],\n\t        controller = ngModel.controller;\n\t    ngModel.controller = ['$scope', '$element', '$attrs', '$injector', function (scope, element, attrs, $injector) {\n\t      var $interpolate = $injector.get('$interpolate');\n\t      attrs.$set('name', $interpolate(attrs.name || '')(scope));\n\t      $injector.invoke(controller, this, {\n\t        '$scope': scope,\n\t        '$element': element,\n\t        '$attrs': attrs\n\t      });\n\t    }];\n\t    return $delegate;\n\t  }]);\n\t  $provide.decorator('formDirective', ['$delegate', function ($delegate) {\n\t    var form = $delegate[0],\n\t        controller = form.controller;\n\t    form.controller = ['$scope', '$element', '$attrs', '$injector', function (scope, element, attrs, $injector) {\n\t      var $interpolate = $injector.get('$interpolate');\n\t      attrs.$set('name', $interpolate(attrs.name || attrs.ngForm || '')(scope));\n\t      $injector.invoke(controller, this, {\n\t        '$scope': scope,\n\t        '$element': element,\n\t        '$attrs': attrs\n\t      });\n\t    }];\n\t    return $delegate;\n\t  }]);\n\t}]);\n\t\n\t// Shared code for the accessible controls\n\tmod.provider('formControlService', function () {\n\t  var self = this,\n\t      counter = 0; // Private variable\n\t\n\t  //\n\t  self.defaults = {\n\t    idPrefix: 'fpFld',\n\t    templates: {\n\t      formCheckbox: {\n\t        template: __webpack_require__(22)\n\t      },\n\t      formDate: {\n\t        template: __webpack_require__(23)\n\t      },\n\t      formInput: {\n\t        template: __webpack_require__(24)\n\t      },\n\t      formRadioButton: {\n\t        template: __webpack_require__(25)\n\t      },\n\t      formSelect: {\n\t        template: __webpack_require__(26)\n\t      },\n\t      requiredMarker: {\n\t        template: __webpack_require__(27)\n\t      }\n\t    }\n\t  };\n\t\n\t  this.$get = ['ngFormLibStringUtil', '$interpolate', function (StringUtil) {\n\t\n\t    var service = {\n\t      defaults: self.defaults,\n\t\n\t      buildDirective: function buildDirective(params) {\n\t        var directive = {\n\t          restrict: 'AE',\n\t          replace: true,\n\t          transclude: true,\n\t          compile: function compile(tElement, tAttr) {\n\t\n\t            service.validateComponentStructure(params.controlName, tElement, params.expectedTemplateElements, tAttr, params.expectedAttributes);\n\t\n\t            // For items that are inside repeaters, if more than one element has the same id, the checkbox stops working.\n\t            // By using an attribute that is not called 'id', we can avoid this issue\n\t            var id = tAttr.uid || service.getUniqueFieldId(),\n\t                name = tAttr.name || id,\n\t                // Doing this *will* break radio buttons, but they SHOULD provide a name anyway (for their own good)\n\t            inputElem = tElement.find(params.inputElementName || 'input'),\n\t                labelElem = tElement.find('label'),\n\t                required = service.getRequiredAttribute(tAttr.required);\n\t\n\t            service.decorateLabel(labelElem, required, id, tAttr.labelClass, tAttr.hideLabel, tAttr.hideRequiredIndicator, tAttr.labelSuffix);\n\t            inputElem = service.decorateInputField(inputElem, tElement, tAttr, id, name, required);\n\t\n\t            // Do component-specific config last\n\t            params.configFn(tElement, tAttr, id, name, inputElem, labelElem);\n\t\n\t            // Clean up special attributes (to make HTML look nicer)\n\t            tElement.removeAttr('uid').removeAttr('name').removeAttr('label').removeAttr('required').removeAttr('field-hint').removeAttr('input-type').removeAttr('hide-label').removeAttr('hideRequiredIndicator').removeAttr('label-class').removeAttr('field-errors').removeAttr('text-errors');\n\t          },\n\t          templateUrl: function templateUrl(element, attr) {\n\t            // Check the element for a \"template\" attribute, which allows customisation-per-control. Otherwise, use the control-wide template.\n\t            return attr.template || service.getHTMLTemplate(element, params.controlName);\n\t          }\n\t        };\n\t\n\t        return directive;\n\t      },\n\t\n\t      getUniqueFieldId: function getUniqueFieldId() {\n\t        return '' + self.defaults.idPrefix + counter++;\n\t      },\n\t\n\t      getHTMLTemplate: function getHTMLTemplate(element, type) {\n\t        // Allow different templates to be applied for different form-styles (eg for horizontal forms, inline forms, \"normal\" forms).\n\t        // This is an advanced feature that most users will not need.\n\t        // E.g.: self.defaults.templates['select']['form-inline'] = 'path/to/your/custom/template.html'\n\t\n\t        // Check this element's parent-form-element-classes to see if they match. First match, wins.\n\t        var parentFormClasses = (element.inheritedData('formElementClasses') || '').split(' ');\n\t        var result = self.defaults.templates[type].template; // The default template, if nothing else is specified.\n\t\n\t        for (var i = 0; i < parentFormClasses.length; i++) {\n\t          var template = self.defaults.templates[type][parentFormClasses[i]];\n\t          if (template) {\n\t            result = template;\n\t            break;\n\t          }\n\t        }\n\t\n\t        return result;\n\t      },\n\t\n\t      addToAttribute: function addToAttribute(element, attributeName, value) {\n\t        var existingVal = element.attr(attributeName);\n\t        element.attr(attributeName, (existingVal ? existingVal + ' ' : '') + value);\n\t      },\n\t\n\t      removeFromAttribute: function removeFromAttribute(element, attributeName, value) {\n\t        // Borrowed this statement from Angular.js\n\t        var newValue = StringUtil.trim((' ' + (element.attr(attributeName) || '') + ' ').replace(/[\\n\\t]/g, ' ').replace(' ' + StringUtil.trim(value) + ' ', ' '));\n\t\n\t        // Remove the attribute if it is empty\n\t        if (newValue === '') {\n\t          element.removeAttr(attributeName);\n\t        } else {\n\t          element.attr(attributeName, newValue);\n\t        }\n\t      },\n\t\n\t      getRequiredAttribute: function getRequiredAttribute(required) {\n\t        // When we set required=\"true\" on a parent directive (like on-off-button), inputElem.attr('required', 'true')\n\t        // becomes <input required=\"required\" due to browser interference. So detect this case, and replace it with \"true\"\n\t        // In v1.3, required=\"true\" becomes required=\"\".\n\t        if (required === 'required' || required === '' || required === 'true') {\n\t          return 'true';\n\t        } else if (required === undefined) {\n\t          return 'false';\n\t        }\n\t        return required;\n\t      },\n\t\n\t      decorateLabel: function decorateLabel(labelElem, required, id, labelClass, hideLabelExpr, hideRequiredIndicator, labelSuffix) {\n\t        if (id) {\n\t          labelElem.attr('for', id);\n\t        }\n\t        if (labelClass) {\n\t          labelElem.addClass(labelClass);\n\t        }\n\t        if (hideLabelExpr) {\n\t          labelElem.attr('ng-class', '{\\'sr-only\\': ' + hideLabelExpr + '}');\n\t        }\n\t        if (!hideRequiredIndicator) {\n\t          labelElem.append('<span required-marker hide=\"!(' + required + ')\"></span>');\n\t        }\n\t        // Some labels have suffix text - text that helps with describing the label, but isn't really the label text.\n\t        // E.g. Amount ($AUD)\n\t        if (labelSuffix) {\n\t          labelElem.text(labelElem.text() + ' ' + labelSuffix);\n\t        }\n\t      },\n\t\n\t      decorateInputField: function decorateInputField(inputElem, hostElement, attr, id, name, required) {\n\t        if (attr.inputType) {\n\t          // inputElem.attr('type', attr.inputType); // THIS WILL NOT WORK ON IE8!\n\t          // Instead, we must replace the entire node with the only property which SHOULD exist on the template: 'class'\n\t          inputElem.replaceWith('<input type=\"' + attr.inputType + '\" class=\"' + inputElem.attr('class') + '\">');\n\t          inputElem = hostElement.find('input');\n\t        }\n\t\n\t        inputElem.attr('id', id);\n\t\n\t        // Allow the name to be interpolated\n\t        inputElem.attr('name', name);\n\t\n\t        // Apply all of the ff-* attributes to the input element. Use the original attribute names\n\t        // attr.$attr contains the snake-case names e.g. 'form-field' vs camel case 'formField'\n\t        for (var a in attr.$attr) {\n\t          if (a.indexOf('ff') === 0) {\n\t            // Don't search for 'ff-' as the '-' has been replaced with camel case now\n\t            var origAttrName = attr.$attr[a].substr(3);\n\t\n\t            if (origAttrName === 'class') {\n\t              inputElem.addClass(attr[a]);\n\t\n\t              // Special case for type property. It *must* be read-only. Therefore, don't write it to the element\n\t              // See http://stackoverflow.com/questions/8378563/why-cant-i-change-the-type-of-an-input-element-to-submit\n\t            } else if (origAttrName !== 'type') {\n\t                inputElem.attr(origAttrName, attr[a]);\n\t              }\n\t\n\t            // Remove all attributes off the host element\n\t            hostElement.removeAttr(attr.$attr[a]);\n\t          }\n\t        }\n\t\n\t        inputElem.attr('ng-required', required);\n\t        inputElem.attr('aria-required', '{{!!(' + required + ')}}'); // evaluates to true / false\n\t        return inputElem;\n\t      },\n\t\n\t      createErrorFeatures: function createErrorFeatures(parentElement, inputElement, name, fieldLabel, fieldErrors, textErrors) {\n\t        if (fieldErrors || textErrors) {\n\t          // Add an fieldErrorControllers attribute to the element, to hook-up the error features\n\t          inputElement.attr('field-error-controller', '');\n\t\n\t          var fieldLabelStr = fieldLabel ? ' field-label=\"' + fieldLabel + '\"' : '';\n\t          var errorContainerElem = _angular2.default.element('<div error-container field-name=\"' + name + '\"' + fieldLabelStr + '></div>');\n\t          if (fieldErrors) {\n\t            errorContainerElem.attr('field-errors', fieldErrors);\n\t          }\n\t          if (textErrors) {\n\t            errorContainerElem.attr('text-errors', textErrors);\n\t          }\n\t          parentElement.append(errorContainerElem);\n\t        }\n\t      },\n\t\n\t      createFieldHint: function createFieldHint(hostElement, inputElement, fieldHint, fieldHintId, fieldHintDisplay) {\n\t        var hintElement;\n\t\n\t        if (fieldHint) {\n\t          // If we have a field hint, add that as well\n\t          if (fieldHintDisplay) {\n\t            // If a field hint display rule exists, implement.\n\t            hintElement = _angular2.default.element('<p ng-if=\"' + fieldHintDisplay + '\" class=\"help-block\" id=\"' + fieldHintId + '\">' + fieldHint + '</p>');\n\t          } else {\n\t            hintElement = _angular2.default.element('<p class=\"help-block\" id=\"' + fieldHintId + '\">' + fieldHint + '</p>');\n\t          }\n\t          hostElement.append(hintElement);\n\t          inputElement.attr('aria-describedby', fieldHintId);\n\t        }\n\t      },\n\t\n\t      buildNgClassExpression: function buildNgClassExpression(inputElem, targetElem) {\n\t        // If the inputElem has an ngModel and/or ngChecked attribute, create the ng-class attribute\n\t        //todo.. test checkbox implementation\n\t        var modelStr = inputElem.attr('ng-model'),\n\t            checkedStr = inputElem.attr('ng-checked'),\n\t            disabledStr = inputElem.attr('ng-disabled'),\n\t            value = inputElem.attr('value'),\n\t            // a string - used for Radio buttons\n\t        ngValue = inputElem.attr('ng-value'),\n\t            // an expression - used for Radio buttons\n\t        ngTrueValue = inputElem.attr('ng-true-value');\n\t\n\t        if (modelStr) {\n\t          if (ngValue || ngTrueValue) {\n\t            modelStr += ' === ' + (ngValue || ngTrueValue);\n\t          } else if (value) {\n\t            // The value is ALWAYS a string\n\t            modelStr += ' === \\'' + value + '\\'';\n\t          } else {\n\t            modelStr += ' === true'; // For checkboxes, in the absence of ng-true-value\n\t          }\n\t        }\n\t\n\t        if (modelStr && checkedStr) {\n\t          modelStr += ' || ' + checkedStr;\n\t        } else if (checkedStr) {\n\t          modelStr = checkedStr;\n\t        }\n\t\n\t        if (modelStr && disabledStr) {\n\t          targetElem.attr('ng-class', '{\\'checked\\': ' + modelStr + ', \\'disabled\\': ' + disabledStr + '}');\n\t        } else if (modelStr) {\n\t          targetElem.attr('ng-class', '{\\'checked\\': ' + modelStr + '}');\n\t        }\n\t      },\n\t\n\t      validateComponentStructure: function validateComponentStructure(componentName, element, requiredElements, attr, requiredAttributes) {\n\t        for (var i = 0; i < requiredElements.length; i++) {\n\t          if (!element.find(requiredElements[i])) {\n\t            throw new Error('The ' + componentName + ' component template requires a ' + requiredElements[i] + ' element.');\n\t          }\n\t        }\n\t\n\t        for (var j = 0; j < requiredAttributes.length; j++) {\n\t          if (!attr[requiredAttributes[j]]) {\n\t            throw new Error('The ' + componentName + ' component requires a ' + requiredAttributes[j] + ' attribute.');\n\t          }\n\t        }\n\t      }\n\t\n\t    };\n\t    return service;\n\t  }];\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.common.utility', []);\n\t\n\texports.default = mod.name;\n\t\n\t\n\tmod.constant('ngFormLibDateUtil', {\n\t  convertDate: function convertDate(dateStr, newSep) {\n\t    // Converts a date between dd/mm/yyyy and yyyy-mm-dd\n\t    if (!dateStr || !newSep || !(newSep === '/' || newSep === '-')) {\n\t      return dateStr;\n\t    }\n\t\n\t    // Choose a separator string that is the 'opposite' of the desired separator\n\t    var oldSep = newSep === '/' ? '-' : '/',\n\t        parts = dateStr.split(oldSep);\n\t\n\t    // if we get a dodgy date OR you tried to convert a date that was already in the correct format, return the input\n\t    if (isNaN(parts.join('')) || parts.length !== 3) {\n\t      return dateStr;\n\t    }\n\t\n\t    // Swap the year and day parts around\n\t    return parts[2] + newSep + parts[1] + newSep + parts[0];\n\t  },\n\t  formatDay: function formatDay(dayOrDate, month, year) {\n\t    var dd = dayOrDate,\n\t        mm = month,\n\t        yyyy = year;\n\t    if (dayOrDate.getUTCDay) {\n\t      dd = dayOrDate.getDate();\n\t      mm = dayOrDate.getMonth() + 1; //January is 0!`\n\t      yyyy = dayOrDate.getFullYear();\n\t    }\n\t    return (dd < 10 ? '0' + dd : dd) + '/' + (mm < 10 ? '0' + mm : mm) + '/' + yyyy;\n\t  },\n\t  dateAdd: function dateAdd(dateStr, numDays) {\n\t    // Return a modified date in ISO format\n\t    var myDate = this.getDate(dateStr);\n\t    myDate.setDate(myDate.getDate() + numDays);\n\t\n\t    return this.formatDay(myDate);\n\t  },\n\t  getToday: function getToday(optionalDate) {\n\t    return this.formatDay(optionalDate || new Date());\n\t  },\n\t  isISODate: function isISODate(dateStr) {\n\t    return typeof dateStr === 'string' && dateStr.indexOf('-') > 0;\n\t  },\n\t  getDate: function getDate(dateStr) {\n\t    if (!this.isISODate(dateStr)) {\n\t      dateStr = this.convertDate(dateStr, '-');\n\t    }\n\t    return new Date(dateStr);\n\t  },\n\t  monthsBetween: function monthsBetween(date1, date2) {\n\t    return date2.getMonth() - date1.getMonth() + 12 * (date2.getFullYear() - date1.getFullYear());\n\t  }\n\t});\n\t\n\tmod.constant('ngFormLibStringUtil', function () {\n\t  var trimRegExp = /^\\s+|\\s+$/g;\n\t\n\t  return {\n\t    trim: function trim(text) {\n\t      if (typeof text === 'string') {\n\t        return text.replace(trimRegExp, '');\n\t      }\n\t      return text;\n\t    }\n\t  };\n\t}());\n\t\n\tmod.constant('ngFormLibNumberUtil', function () {\n\t  var isDigitsRegExp = /^\\d+$/;\n\t\n\t  return {\n\t    isDigits: function isDigits(text) {\n\t      return isDigitsRegExp.test(text);\n\t    }\n\t  };\n\t}());\n\t\n\tmod.constant('ngFormLibObjectUtil', {\n\t  getUniqueId: function getUniqueId() {\n\t    return ('' + new Date().getTime() + Math.random()).replace(/\\./, '');\n\t  },\n\t  toArray: function toArray(obj) {\n\t    var arr = [];\n\t    for (var i in obj) {\n\t      if (obj.hasOwnProperty(i)) {\n\t        arr[arr.length] = { key: i, value: obj[i] };\n\t      }\n\t    }\n\t    arr.sort(function compare(a, b) {\n\t      return a.key < b.key;\n\t    });\n\t    return arr;\n\t  }\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _FormControlService = __webpack_require__(4);\n\t\n\tvar _FormControlService2 = _interopRequireDefault(_FormControlService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.common.fieldErrorController', [_FormControlService2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t/**\n\t * The Field Error Controller directive is designed to indicate to the browser when the field is in error\n\t *  and what the errors are. It applies the form-policy for showing errors\n\t *\n\t * It works in tandem with the form controller (and FormPolicy.js) to identify when a form-element has an error, and decorates\n\t *  the element accordingly.\n\t *\n\t * It also toggles the fieldController.fieldState flag, based on the form policy provided\n\t *\n\t */\n\t\n\t// INPUT:\n\t//  <input ... field-error-controller></input>\n\t\n\t// OUTPUT:\n\t//  <input ... aria-invalid=\"false/true\" aria-describedby=\"fieldId-errors\">\n\t\n\tmod.directive('fieldErrorController', ['formControlService', '$timeout', function (formControlService, $timeout) {\n\t\n\t  function updateAriaFeatures(fieldState, element, formName, fieldName) {\n\t    element.attr('aria-invalid', fieldState === 'error');\n\t    var errorElemId = formName + '-' + fieldName + '-errors-aria';\n\t\n\t    if (fieldState === 'error') {\n\t      // Use the errorContainer's special ARIA element as the source of the error text\n\t      formControlService.addToAttribute(element, 'aria-describedby', errorElemId);\n\t    } else {\n\t      formControlService.removeFromAttribute(element, 'aria-describedby', errorElemId);\n\t    }\n\t  }\n\t\n\t  function updateElementStyle(fieldState, element, formPolicy) {\n\t    element[fieldState === 'error' ? 'addClass' : 'removeClass'](formPolicy.fieldErrorClass);\n\t    element[fieldState === 'success' ? 'addClass' : 'removeClass'](formPolicy.fieldSuccessClass);\n\t  }\n\t\n\t  function setupCanShowErrorPropertyOnNgModelController(scope, formController, ngModelController, element, name) {\n\t    // Using the form policy, determine when to show errors for this field\n\t    var formPolicy = formController._policy,\n\t        formName = formController.$name,\n\t        fieldName = formName + '.' + name,\n\t        stateConditions = formPolicy.stateDefinitions(formName, fieldName);\n\t\n\t    formPolicy.checkForStateChanges(formController._scope, element, name, stateConditions, ngModelController, formController);\n\t  }\n\t\n\t  return {\n\t    restrict: 'AE',\n\t    require: ['?ngModel', '?^form', '?^formGroup'], // Require the formController controller somewhere in the parent hierarchy\n\t    replace: true,\n\t    link: function link(scope, element, attr, controllers) {\n\t      // Tried to use a template string, but the model was not binding properly. Using $compile() works :)\n\t      var ngModelController = controllers[0],\n\t          formController = controllers[1],\n\t          formGroupElement = (controllers[2] || {}).$element || element,\n\t          // This looks for a parent directive called formGroup, which has a controller, which has an $element property\n\t      name = attr.name;\n\t\n\t      if (formController) {\n\t        var formName = formController.$name,\n\t            errorBehaviour = formController._applyFormBehaviourOnStateChangePolicy; // returns a function which encapsulates the form policy rules for the behaviour to apply when errors show\n\t\n\t        if (ngModelController) {\n\t          setupCanShowErrorPropertyOnNgModelController(scope, formController, ngModelController, element, name);\n\t        }\n\t\n\t        // When the error-showing flag changes, update the field style\n\t        formController._scope.$watch(formName + '.' + name + '.fieldState', function (fieldState) {\n\t          updateAriaFeatures(fieldState, element, formName, name);\n\t          updateElementStyle(fieldState, formGroupElement, formController._policy);\n\t\n\t          // Apply the error behaviour behaviour\n\t          errorBehaviour.applyBehaviour(element, fieldState, false);\n\t        });\n\t\n\t        // Listen to form-submit events, to determine what to focus on too\n\t        scope.$on('event:FormSubmitAttempted', function () {\n\t          // Make sure that the field-level watchers have a chance to fire first, so use a timeout\n\t          $timeout(function () {\n\t            errorBehaviour.applyBehaviour(element, ngModelController.fieldState, true);\n\t          }, 1);\n\t        });\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\t// This directive\n\tmod.directive('formGroup', [function () {\n\t  return {\n\t    restrict: 'AC',\n\t    controller: ['$scope', '$element', function ($scope, $element) {\n\t      this.$element = $element;\n\t    }]\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _index = __webpack_require__(3);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formCheckbox', [_index2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//  <form-checkbox id=\"id\" name=\"name\" required=\"{{expression}}\"\n\t//      ff-class=\"span12\" ff-ng-model=\"application.contentType\" ff-value=\"software\" ff-aria-label=\"Software\"\n\t//        ff-ng-click=\"doSomething()\"\n\t//      field-errors=\"{required: 'Please select'}\"\n\t//      text-errors=\"['wrong value']\"\n\t//      >My label with <a href=\"http://www.google.com/\">HTML bits</a> in it</form-checkbox>\n\t\n\t// OUTPUT:\n\t\n\tmod.directive('formCheckbox', ['formControlService', function (formControlService) {\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formCheckbox',\n\t    expectedTemplateElements: ['input', 'label', 'div'],\n\t    expectedAttributes: [],\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem) {\n\t      // Move the class attribute from the outer-DIV to the checkbox DIV (special case)\n\t      var checkboxDiv = tElement.find('div');\n\t      checkboxDiv.addClass(tElement.attr('class'));\n\t      tElement.removeAttr('class');\n\t\n\t      formControlService.createErrorFeatures(tElement, inputElem, name, '', tAttr.fieldErrors, tAttr.textErrors);\n\t      formControlService.buildNgClassExpression(inputElem, inputElem); // Put the ng-class onto the input element itself, as this makes styling easier\n\t    }\n\t  });\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _common = __webpack_require__(3);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formDate', [_common2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//    <div form-date id=\"toDate\" name=\"toDate\" label=\"To date\" hide-label=\"true\" input-type=\"text\"\n\t//    ff-ng-model=\"acctCtrl.search.toDate\" ff-max-date=\"today\" ff-bs-show=\"acctCtrl.datePickers.datePickerTo\"\n\t//    ff-ng-blur=\"acctCtrl.toggleDatePicker('datePickerTo', true)\"\n\t//    ff-ng-focus=\"acctCtrl.toggleDatePicker('datePickerFrom', true)\"\n\t//    ff-class=\"form-control input-beta input-date\"\n\t//    field-errors=\"{date: 'ERROR.DATE_INVALID'}\" >\n\t//      <i class=\"calendar\" ng-click=\"acctCtrl.toggleDatePicker('datePickerTo')\"></i>\n\t//    </div>\n\t\n\tmod.directive('formDate', ['formControlService', function (formControlService) {\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formDate',\n\t    expectedTemplateElements: ['input', 'label'],\n\t    expectedAttributes: ['label'],\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem, labelElem) {\n\t      labelElem.prepend(tAttr.label);\n\t\n\t      //formControlService.decorateInputGroup(tElement.find('div'), tAttr.inputGroupClass);\n\t      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n\t      formControlService.createErrorFeatures(inputElem.parent(), inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n\t    }\n\t  });\n\t}]);\n\t\n\tmod.directive('formDateFormat', ['ngFormLibDateUtil', function (DateUtil) {\n\t  // All dates greater than AD 0 and less than AD 10000 in dd/mm/yyyy format\n\t  // RegEx behaves oddly if /g is uses in Regexp.test() situations\n\t  var dateRegEx = /^(((0[1-9]|[12][0-9]|3[01])([\\/])(0[13578]|10|12)([\\/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([\\/])(0[469]|11)([\\/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([\\/])(02)([\\/])(\\d{4}))|((29)(\\/)(02)([\\/])([02468][048]00))|((29)([\\/])(02)([\\/])([13579][26]00))|((29)([\\/])(02)([\\/])([0-9][0-9][0][48]))|((29)([\\/])(02)([\\/])([0-9][0-9][2468][048]))|((29)([\\/])(02)([\\/])([0-9][0-9][13579][26])))$/;\n\t\n\t  return {\n\t    require: 'ngModel',\n\t    priority: 150, // Higher priority than ui-mask (100), so the postLink function runs last\n\t    link: function link(scope, elem, attrs, ctrl) {\n\t\n\t      ctrl.$parsers.unshift(function (viewValue) {\n\t\n\t        // If viewValue is undefined or null, jump out\n\t        if (!viewValue) {\n\t          ctrl.$setValidity('date', true);\n\t          ctrl.$setValidity('minDate', true); // Turn off the error if the date format isn't valid\n\t          ctrl.$setValidity('maxDate', true); // Turn off the error if the date format isn't valid\n\t          return viewValue;\n\t        }\n\t\n\t        // If viewValue is a string of 8 digits, then convert it to dd/dd/dddd first\n\t        if (viewValue.length === 8 && !isNaN(viewValue * 1)) {\n\t          viewValue = viewValue.substr(0, 2) + '/' + viewValue.substr(2, 2) + '/' + viewValue.substr(4);\n\t        }\n\t\n\t        // Check that it is a valid date\n\t        var dateFormatValid = dateRegEx.test(viewValue) || typeof viewValue === 'undefined' || !viewValue;\n\t        ctrl.$setValidity('date', dateFormatValid);\n\t\n\t        //console.log('dateInput: ' + viewValue + ', ' + ctrl.$modelValue);\n\t\n\t        // If the date is valid\n\t        if (dateFormatValid && viewValue) {\n\t          var fieldDate = DateUtil.getDate(viewValue);\n\t          // and there is a min date, check if the value is greater than the min date\n\t          if (attrs.minDate) {\n\t            var minDate = DateUtil.getDate(attrs.minDate);\n\t            ctrl.$setValidity('minDate', fieldDate.getTime() >= minDate.getTime());\n\t          } else {\n\t            ctrl.$setValidity('minDate', true);\n\t          }\n\t          // and there is a max date, check if the value is less than the max date\n\t          if (attrs.maxDate) {\n\t            var maxDate;\n\t\n\t            if (attrs.maxDate === 'today') {\n\t              maxDate = DateUtil.getDate(DateUtil.getToday());\n\t            } else {\n\t              maxDate = DateUtil.getDate(attrs.maxDate);\n\t            }\n\t\n\t            ctrl.$setValidity('maxDate', fieldDate.getTime() <= maxDate.getTime());\n\t          } else {\n\t            ctrl.$setValidity('maxDate', true);\n\t          }\n\t        } else {\n\t          ctrl.$setValidity('minDate', true); // Turn off the error if the date format isn't valid\n\t          ctrl.$setValidity('maxDate', true); // Turn off the error if the date format isn't valid\n\t        }\n\t        return viewValue;\n\t      });\n\t\n\t      ctrl.$viewChangeListeners.push(function () {\n\t        // If there is a date-change attribute, execute it when the control is valid\n\t        if (attrs.dateChange && ctrl.$valid) {\n\t          scope.$eval(attrs.dateChange);\n\t        }\n\t      });\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _common = __webpack_require__(3);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formInput', [_common2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//  <form-input id=\"\" name=\"\" label=\"Last name\" required=\"{{expression}}\"\n\t//      ff-class=\"span12\" input-type=\"text|tel|email\" ff-ng-model=\"application.lastName\"\n\t//      ff-maxlength=\"40\" ff-ng-pattern=\"/^[a-zA-Z0-9 \\-.']+$/\"\n\t//      field-hint=\"This must be the last name of the person who originally applied for the service.\"\n\t//      field-errors=\"{required: 'Please enter a valid last name', pattern: 'Please enter a valid last name'}\"\n\t//      text-errors=\"['data.errors.']\"\n\t//      content-class=\"span3\"\n\t//      >My content</form-input>\n\t\n\t// OUTPUT:\n\t\n\tmod.directive('formInput', ['formControlService', function (formControlService) {\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formInput',\n\t    expectedTemplateElements: ['input', 'label'],\n\t    expectedAttributes: ['label', 'inputType'],\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem, labelElem) {\n\t      labelElem.prepend(tAttr.label);\n\t      addPlaceholder(inputElem, tAttr.placeholder); // Do this to be API-compatible with the form-select control. ff-placeholder is still supported. Use one or the other.\n\t\n\t      // If the user wants to use 'input-addon-prefix' or 'input-addon-suffix', change the DOM\n\t      var hasInputGroup = addInputGroup(inputElem, tAttr.inputPrefix, tAttr.inputSuffix);\n\t      var parentElemForErrors = hasInputGroup ? inputElem.parent().parent() : inputElem.parent();\n\t\n\t      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n\t      formControlService.createErrorFeatures(parentElemForErrors, inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n\t    }\n\t  });\n\t}]);\n\t\n\tfunction addPlaceholder(inputElem, placeholderText) {\n\t  if (placeholderText) {\n\t    inputElem.attr('placeholder', placeholderText);\n\t  }\n\t}\n\t\n\tfunction addInputGroup(inputElem, inputGroupPrefix, inputGroupSuffix) {\n\t  if (inputGroupPrefix || inputGroupSuffix) {\n\t    inputElem.wrap('<div class=\"input-group\">'); //inputElem.parent(); // This should be the 'control-row' element//wrap('<div class=\"input-group\">');\n\t    var wrapper = inputElem.parent();\n\t\n\t    if (inputGroupPrefix) {\n\t      wrapper.prepend('<span class=\"input-group-addon\">' + inputGroupPrefix + '</span>');\n\t    }\n\t    if (inputGroupSuffix) {\n\t      wrapper.append('<span class=\"input-group-addon\">' + inputGroupSuffix + '</span>');\n\t    }\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _common = __webpack_require__(3);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formRadioButton', [_common2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//  <form-radio-button uid=\"fld\" name=\"name\" aria-label=\"Book Type\" label-class=\"btn btn-toggle\"\n\t//    ff-class=\"someCSS\" ff-ng-model=\"application.bookType\" ff-value=\"Fiction\" ng-click=\"loadFiction()\" class=\"span6\">\n\t//     <icon class=\"icon-fiction\"></icon>Fiction\n\t//  </form-radio-button>\n\t\n\t// OUTPUT:\n\t\n\tmod.directive('formRadioButton', ['formControlService', function (formControlService) {\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formRadioButton',\n\t    expectedTemplateElements: ['input', 'label', 'div'],\n\t    expectedAttributes: [], // The template should NOT have a form-group element inside it, as this has to be specified externally (due to the group-nature of radio buttons)\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem) {\n\t      // Move the class attribute from the outer-DIV to the radio-button DIV (special case)\n\t      var rbDiv = tElement.find('div');\n\t      rbDiv.addClass(tElement.attr('class'));\n\t      tElement.removeAttr('class');\n\t\n\t      formControlService.createErrorFeatures(tElement, inputElem, name, '', tAttr.fieldErrors, tAttr.textErrors);\n\t      formControlService.buildNgClassExpression(inputElem, inputElem); // Put the ng-class onto the input element itself, as this makes styling easier\n\t    }\n\t  });\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formReset', []);\n\t\n\texports.default = mod.name;\n\t\n\t\n\tmod.directive('formReset', ['$parse', function ($parse) {\n\t\n\t  function resetFieldState(controlMap) {\n\t    // Loops through the controlMap and reset's each field's state\n\t    for (var item in controlMap) {\n\t      if (controlMap.hasOwnProperty(item)) {\n\t        var controlList = controlMap[item];\n\t        for (var j = 0, jLen = controlList.length; j < jLen; j++) {\n\t          var control = controlList[j].controller;\n\t          control.fieldState = '';\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return {\n\t    restrict: 'A',\n\t    require: '^form',\n\t    link: function link(scope, element, attr, controller) {\n\t      var ngModelGet = $parse(attr.formReset),\n\t          ngModelSet = ngModelGet.assign;\n\t\n\t      if (!ngModelSet) {\n\t        throw Error('formReset requires an assignable scope-expression. \"' + attr.formReset + '\" is un-assignable.');\n\t      }\n\t\n\t      // Get a copy of the data as soon as the directive is created, which is after the scope/controller has been initialised (safe)\n\t      var originalData = _angular2.default.copy(ngModelGet(scope));\n\t\n\t      element.on('click', function () {\n\t        if (typeof controller.setSubmitted === 'function') {\n\t          controller.setSubmitted(false);\n\t        }\n\t        // Use a *copy* of the original data, as we don't want originalData to be modified by subsequent changes to the model by the form controls\n\t        ngModelSet(scope, _angular2.default.copy(originalData));\n\t        resetFieldState(controller._controls || {});\n\t        controller.$setPristine();\n\t\n\t        scope.$emit('event:FormReset');\n\t        scope.$digest();\n\t      });\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _common = __webpack_require__(3);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formSelect', [_common2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//  <form-select id=\"frm-size\" name=\"bookSize\" required=\"true\" label=\"Approximate size\"\n\t//    ff-class=\"span12\" ff-ng-model=\"model.size\" placeholder=\"Select a size bracket\"\n\t//    ff-ng-options=\"option.value as option.name for option in refData.bookSizes\"\n\t//    field-errors=\"{required: 'Please select a size bracket'}\"\n\t//    text-errors=\"['data.errors']\"></form-select>\n\t\n\t// OUTPUT:\n\t\n\tmod.directive('formSelect', ['formControlService', function (formControlService) {\n\t\n\t  function addPlaceholder(selectElem, placeholderText) {\n\t    if (placeholderText) {\n\t      selectElem.append('<option translate value=\"\">' + placeholderText + '</option>');\n\t    }\n\t  }\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formSelect',\n\t    inputElementName: 'select',\n\t    expectedTemplateElements: ['select', 'label'],\n\t    expectedAttributes: ['label'],\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem, labelElem) {\n\t      labelElem.prepend(tAttr.label);\n\t      addPlaceholder(inputElem, tAttr.placeholder); // Adds the extra option element to the start of the <option>\n\t\n\t      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n\t      formControlService.createErrorFeatures(inputElem.parent(), inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n\t    }\n\t  });\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formSubmit', []);\n\t\n\texports.default = mod.name;\n\t\n\t/**\n\t *  formSubmit - Executes an expression when the form is valid (essentially a form.submit() handler).\n\t *\n\t *  It can be applied to either the form element or to a button.\n\t *\n\t */\n\t\n\tmod.directive('formSubmit', ['$parse', function ($parse) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['^form'], // Get the form controller\n\t    link: function link(scope, element, attr, controller) {\n\t\n\t      var fn = $parse(attr.formSubmit) || _angular2.default.noop,\n\t          isForm = element[0].tagName === 'FORM',\n\t          formController = controller[0];\n\t\n\t      element.bind(isForm ? 'submit' : 'click', function (event) {\n\t\n\t        formController.setSubmitted(true);\n\t\n\t        scope.$apply(function () {\n\t          //scope.$emit('event:FormSubmitAttempted');\n\t\n\t          if (formController.$valid) {\n\t            if (fn(scope, { $event: event }) !== false) {\n\t              // Needed by the tracking tool as it clears the input data after a submission.\n\t              // Potentially, form field validation to be done here, but unnecessary at the moment.\n\t              // The reset behaviour can be over-ridden by returning false from the called function(maybe prevent default aswell?)\n\t              formController.setSubmitted(false);\n\t              formController.$setPristine();\n\t            }\n\t          } else {\n\t            event.preventDefault();\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tvar _FormCheckbox = __webpack_require__(7);\n\t\n\tvar _FormCheckbox2 = _interopRequireDefault(_FormCheckbox);\n\t\n\tvar _FormDate = __webpack_require__(8);\n\t\n\tvar _FormDate2 = _interopRequireDefault(_FormDate);\n\t\n\tvar _FormInput = __webpack_require__(9);\n\t\n\tvar _FormInput2 = _interopRequireDefault(_FormInput);\n\t\n\tvar _FormRadioButton = __webpack_require__(10);\n\t\n\tvar _FormRadioButton2 = _interopRequireDefault(_FormRadioButton);\n\t\n\tvar _FormReset = __webpack_require__(11);\n\t\n\tvar _FormReset2 = _interopRequireDefault(_FormReset);\n\t\n\tvar _FormSelect = __webpack_require__(12);\n\t\n\tvar _FormSelect2 = _interopRequireDefault(_FormSelect);\n\t\n\tvar _FormSubmit = __webpack_require__(13);\n\t\n\tvar _FormSubmit2 = _interopRequireDefault(_FormSubmit);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// We need the utility module for the ngFormLibDateUtil.getDate() method for the formDateFormat directive, and ngFormLibStringUtil.trim() in controls.common\n\tvar mod = _angular2.default.module('ngFormLib.controls', [_ErrorMessageContainer2.default, _FormCheckbox2.default, _FormDate2.default, _FormInput2.default, _FormRadioButton2.default, _FormReset2.default, _FormSelect2.default, _FormSubmit2.default]);\n\t\n\texports.default = mod.name;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _FormControlService = __webpack_require__(4);\n\t\n\tvar _FormControlService2 = _interopRequireDefault(_FormControlService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.requiredMarker', [_FormControlService2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// Add a simple \"required\" marker that is not read-out by screen readers (as the field should also have a required indicator)\n\t//\n\t// INPUT:\n\t//  <span required-marker></span>\n\t//  <span required-marker hide=\"isNotRequired\">Some Text</span>\n\t\n\t// OUTPUT:\n\t//  <span class=\"required\" aria-hidden=\"true\" ng-class=\"{\\'ng-hide\\': hide}\" ng-transclude=\"\"></span>\n\t//  <span class=\"required\" aria-hidden=\"true\" ng-class=\"{\\'ng-hide\\': hide}\" ng-transclude=\"\" hide=\"isNotRequired\">Some Text</span>\n\t\n\tmod.directive('requiredMarker', ['formControlService', function (formControlService) {\n\t\n\t  return {\n\t    restrict: 'AE',\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function templateUrl(element, attr) {\n\t      return attr.template || formControlService.getHTMLTemplate(element, 'requiredMarker');\n\t    },\n\t    scope: {\n\t      hide: '='\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularAnimate = __webpack_require__(28);\n\t\n\tvar _angularAnimate2 = _interopRequireDefault(_angularAnimate);\n\t\n\tvar _FormPolicy = __webpack_require__(17);\n\t\n\tvar _FormPolicy2 = _interopRequireDefault(_FormPolicy);\n\t\n\tvar _controls = __webpack_require__(14);\n\t\n\tvar _controls2 = _interopRequireDefault(_controls);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib', [_angularAnimate2.default, _FormPolicy2.default,\n\t//    Add the policies you want, or define your own:\n\t//    'ngFormLib.policy.checkForStateChanges',\n\t//    'ngFormLib.policy.displayError',\n\t//    'ngFormLib.policy.focusBehaviour',\n\t_controls2.default]);\n\t\n\texports.default = mod.name;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// The form policy intentionally has no hard dependencies.\n\t// If there are form-policy values that exist when the service is being constructed, it will use them.\n\t// Otherwise it will use no-op policy functions.\n\tvar mod = _angular2.default.module('ngFormLib.policy', []);\n\t\n\texports.default = mod.name;\n\t\n\t// This is a configurable service\n\t// It should contain the _default_ values for form policies\n\t\n\tmod.provider('formPolicyService', function () {\n\t  var self = this,\n\t      noop = _angular2.default.noop,\n\t      nullBehaviourOnStateChange = function nullBehaviourOnStateChange() {\n\t    return {\n\t      applyBehaviour: noop,\n\t      resetBehaviour: noop\n\t    };\n\t  },\n\t      nullStateChanges = function nullStateChanges() {\n\t    return {};\n\t  };\n\t\n\t  self.defaults = {\n\t    formSubmitAttemptedClass: 'form-submit-attempted',\n\t    fieldErrorClass: 'has-error',\n\t    fieldSuccessClass: 'has-success',\n\t    behaviourOnStateChange: null, // Previously called focusBehavior\n\t    checkForStateChanges: null,\n\t    stateDefinitions: null,\n\t    fieldFocusScrollOffset: 0\n\t  };\n\t\n\t  this.$get = ['$injector', function ($injector) {\n\t\n\t    function getService(name) {\n\t      try {\n\t        return $injector.get(name);\n\t      } catch (e) {\n\t        return null; // Provider-not-found error, ignore and move on\n\t      }\n\t    }\n\t\n\t    // Policy precedence: this.defaults, policy-value-object, noop\n\t    self.defaults.behaviourOnStateChange = self.defaults.behaviourOnStateChange || getService('formPolicyBehaviourOnStateChange') || nullBehaviourOnStateChange;\n\t    self.defaults.checkForStateChanges = self.defaults.checkForStateChanges || getService('formPolicyCheckForStateChanges') || noop;\n\t    self.defaults.stateDefinitions = self.defaults.stateDefinitions || getService('formPolicyStateDefinitions') || nullStateChanges;\n\t\n\t    var policyService = {\n\t      getCurrentPolicy: function getCurrentPolicy() {\n\t        return _angular2.default.copy(self.defaults);\n\t      }\n\t    };\n\t\n\t    return policyService;\n\t  }];\n\t});\n\t\n\tfunction formDirective(formPolicyService) {\n\t\n\t  return {\n\t    //priority: -1,\n\t    restrict: 'AE',\n\t    require: ['?form'], // Tells the directive to get the controller for the 'form' directive, which is the FormController controller\n\t    compile: function compile(tElement, tAttr) {\n\t\n\t      // Use element.data() to store a reference to this element for use by child.inheritedData()\n\t      // Will storing an element this way cause a memory leak? Or should I just store the data I currently need (attr.class)\n\t      // This has to happen during the compile step, as the children need access to the variable when they are compiled\n\t      //  ('class' is a reserved word to JavaScript, so we need to treat it as a string)\n\t      tElement.data('formElementClasses', tAttr['class']); //jscs:ignore\n\t\n\t      return {\n\t        pre: function pre(scope, element, attr, controller) {\n\t          // We want to extend the FormController by adding a form policy\n\t          var formController = controller[0];\n\t          formController._policy = _angular2.default.extend(formPolicyService.getCurrentPolicy(), scope.$eval(attr.formPolicy));\n\t\n\t          // Add a reference to the <form> element's scope to the formController, to support showing errors for nested components\n\t          formController._scope = scope;\n\t\n\t          // Determine if we have a parent form controller. If we do, we want to use it for the focus behaviour\n\t          formController._parentController = element.parent().controller('form');\n\t\n\t          if (!formController._parentController) {\n\t            // We also want to add an element reference when a control is added\n\t            formController._controls = {};\n\t          }\n\t\n\t          // Generate the focus policy function for use by other directive\n\t          formController._applyFormBehaviourOnStateChangePolicy = formController._policy.behaviourOnStateChange(formController);\n\t\n\t          // Add/remove a class onto the form based on the value of the formSubmitted variable\n\t          formController.setSubmitted = function (value, tellNoOne) {\n\t            element[value ? 'addClass' : 'removeClass'](formController._policy.formSubmitAttemptedClass);\n\t            formController._formSubmitAttempted = value;\n\t            formController._applyFormBehaviourOnStateChangePolicy.resetBehaviour();\n\t\n\t            if (value && !tellNoOne) {\n\t              scope.$broadcast('event:FormSubmitAttempted');\n\t            }\n\t          };\n\t\n\t          // Flag to indicate whether the form has been submitted\n\t          formController._formSubmitAttempted = false;\n\t          formController._applyFormBehaviourOnStateChangePolicy.resetBehaviour();\n\t\n\t          // If this form is an ngForm (in that it has a parent 'form'), then we need to make sure that\n\t          // when the parent form is submitted or reset, the same thing happens to the child forms\n\t          if (formController._parentController) {\n\t            scope.$watch(function () {\n\t              return formController._parentController._formSubmitAttempted;\n\t            }, function (value) {\n\t              if (value !== undefined) {\n\t                //formController.setSubmitted(!!value, true);  // Don't send another notification, just update our own state\n\t                formController.setSubmitted(!!value); // Don't send another notification, just update our own state\n\t              }\n\t            });\n\t          }\n\t        }\n\t      };\n\t    }\n\t  };\n\t}\n\tmod.directive('form', ['formPolicyService', formDirective]);\n\tmod.directive('ngForm', ['formPolicyService', formDirective]);\n\t\n\t// We want our formController to expose the list of controls that are registered with the form,\n\t// including controls inside sub-forms. That allows us to reset them directly. Relying simply on the fieldName\n\t// does not work when using sub-forms inside ng-repeaters.\n\t\n\tvar inputElements = ['input', 'select'];\n\t\n\t_angular2.default.forEach(inputElements, function (inputElem) {\n\t  mod.directive(inputElem, function () {\n\t\n\t    function hookupElementToNameToElementMap(formController, element, fieldName, fieldController) {\n\t      // Each element in the map is an array, because form elements *can have the same name*!\n\t      var map = formController._controls;\n\t      if (!map[fieldName]) {\n\t        map[fieldName] = [];\n\t      }\n\t      // Add the field to the end of the list of items with the same name\n\t      map[fieldName][map[fieldName].length] = { 'element': element, 'controller': fieldController };\n\t\n\t      element.on('$destroy', function () {\n\t        // Delete just this element from the map of controls\n\t        var map = formController._controls[element.attr('name')];\n\t        var elementId = element.attr('id');\n\t        for (var i = 0; i < map.length; i++) {\n\t          if (map[i].element.attr('id') === elementId) {\n\t            map.splice(i, 1);\n\t            break;\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    return {\n\t      restrict: 'E',\n\t      require: ['?^form', '?ngModel'],\n\t      link: {\n\t        pre: function pre(scope, element, attr, controllers) {\n\t          if (!controllers[0]) {\n\t            return;\n\t          }\n\t\n\t          var rootFormController = controllers[0]._parentController || controllers[0],\n\t              fieldController = controllers[1],\n\t              name = attr.name;\n\t\n\t          if (rootFormController && rootFormController._controls) {\n\t            hookupElementToNameToElementMap(rootFormController, element, name, fieldController);\n\t          }\n\t        }\n\t      }\n\t    };\n\t  });\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */,\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormCheckboxTemplate.tpl.html\";\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormDateInputTemplate.tpl.html\";\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormInputTemplate.tpl.html\";\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormRadioButtonTemplate.tpl.html\";\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormSelectTemplate.tpl.html\";\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/RequiredMarkerTemplate.tpl.html\";\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_28__;\n\n/***/ },\n/* 29 */,\n/* 30 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_30__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** lib/ngFormLib.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a5df63fbd71118df4315\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 1\n ** module chunks = 0 1\n **/","import angular from 'angular';\nimport ngTranslate from 'angular-translate';\n\nconst mod = angular.module('ngFormLib.controls.errorMessageContainer', [ngTranslate]);\n\nexport default mod.name;\n\n\n//angular.module('ngFormLib.controls.errorMessageContainer', ['pascalprecht.translate'])\n\n/**\n * This directive is really a FIELD error message container - it is designed to work with fields exclusively\n */\nmod.directive('errorContainer', ['$compile', '$filter', function($compile, $filter) {\n\n  function translateError(errorMessage, fieldLabel) {\n    var firstLetterIsAVowel = fieldLabel ? ('aeiou'.indexOf(fieldLabel[0].toLowerCase()) !== -1) : undefined;\n    return $filter('translate')(errorMessage, {pronoun: firstLetterIsAVowel ? 'an' : 'a', fieldLabel: fieldLabel});\n  }\n\n  function ErrorController(element) {\n    var errors = [],\n      ariaElement = element;\n\n    return {\n      addError: function(errorType, errorMessage, fieldLabel) {\n        errors[errorType] = translateError(errorMessage, fieldLabel);\n      },\n\n      removeError: function(errorType) {\n        delete errors[errorType];\n      },\n\n      refreshErrorText: function() {\n        var str = '', i = 0;\n        for (var type in errors) {\n          if (errors.hasOwnProperty(type)) {\n            str += 'Error ' + (++i) + ', ' + errors[type] + ',';\n          }\n        }\n\n        if (i === 1) {\n          str = '. There is 1 error for this field. ' + str;\n        } else if (i > 1) {\n          str = '. There are ' + i + ' errors for this field. ' + str;\n        }\n        ariaElement.text(str);\n      }\n    };\n  }\n\n  function generateErrorTag(errorType, errorText, fieldLabel) {\n    return '<div class=\"text-error ec2-' + errorType + '\"><span class=\"text-error-wrap\">' + translateError(errorText, fieldLabel) + '</span></div>';\n  }\n\n  /**\n   * Handle the field-based error messages\n   */\n  function toggleErrorVisibilityOnError(controller, formController, scope, element, watchExpr, errorType, errorText, fieldLabel) {\n    //console.log('watchExpr = ' + watchExpr);\n    formController._scope.$watch(watchExpr, function(newValue) {\n      if (newValue) {\n        // The error text could contain an interpolation string, so we need to compile it\n        var val = $compile(generateErrorTag(errorType, errorText, fieldLabel))(scope);\n        element.append(val);\n        controller.addError(errorType, errorText, fieldLabel);\n      } else {\n        removeErrorMessage(controller, formController, element, errorType);\n      }\n      controller.refreshErrorText();\n    });\n  }\n\n  /**\n   * Handle text errors. Text errors are associated with a scope, rather than with a field.\n   * This means we can clear them from the scope when the field-they-are-associated-with is changed.\n   */\n  function toggleErrorVisibilityForTextError(errorController, formController, fieldController, scope, element, watchExpr, fieldLabel) {\n    //console.log('Watching error: ' + watchExpr);\n\n    formController._scope.$watch(watchExpr, function(newValue) {\n      // Update the validity of the field's \"watchExpr\" error-key to match the value of the errorText\n      fieldController.$setValidity(watchExpr, !newValue);\n\n      // Remove the old error message for this same errorType first, in cases where the error message is changing.\n      removeErrorMessage(errorController, formController, element, watchExpr);\n\n      if (newValue) {\n        // No need to compile the error message as we already have its value\n        element.append(generateErrorTag(watchExpr, newValue, fieldLabel));\n        errorController.addError(watchExpr, newValue, fieldLabel);\n\n        // Turn the border red by sending a 'form-submit-attempted' event\n        formController.setSubmitted(true);\n      }\n      errorController.refreshErrorText();\n    });\n\n    // When the field changes, clear the errorText value\n    fieldController.$viewChangeListeners.push(function() {\n      if (scope.$eval(watchExpr)) {\n        scope.$eval(watchExpr + ' = null');\n      }\n    });\n  }\n\n\n  function removeErrorMessage(controller, formController, element, errorType) {\n    // find the div with our special class, then remove it\n    var divs = element.find('div');\n    for (var len = divs.length, i = len - 1; i > -1; i--) {\n      if (divs.eq(i).hasClass('ec2-' + errorType)) {\n        divs.eq(i).remove();\n      }\n    }\n    controller.removeError(errorType);\n  }\n\n  return {\n    restrict: 'AE',\n    require: ['^form'], // Require the formController controller somewhere in the parent hierarchy (mandatory for field-errors)\n    template: '<div class=\"container-error\"></div>',\n    replace: true,\n    link: function(scope, element, attr, controllers) {\n\n      var fieldName = attr.fieldName,\n        fieldLabel = attr.fieldLabel || '',\n        formController = controllers[0],\n        formName = formController.$name,\n        formField = formName + '.' + fieldName,\n        fieldErrors = scope.$eval(attr.fieldErrors || []),  // You can escape interpolation brackets inside strings by doing  \\{\\{   - wow!\n        textErrors = scope.$eval(attr.textErrors || []);\n\n      element.attr('id', formName + '-' + fieldName + '-errors');\n      element.append('<span class=\"sr-only\" aria-hidden=\"true\" id=\"' + formName + '-' + fieldName + '-errors-aria\"></span>');\n\n      var ariaElement = element.find('span'),\n        errorController = new ErrorController(ariaElement);   // new? Maybe make this the directive's controller instead\n\n      for (var error in fieldErrors) {\n        if (fieldErrors.hasOwnProperty(error)) {\n          var errorShowCondition = formField + '.fieldState === \"error\" && ' + formField + '.$error.' + error;\n          toggleErrorVisibilityOnError(errorController, formController, scope, element, errorShowCondition, error, fieldErrors[error], fieldLabel);\n        }\n      }\n\n      // Watch formController[fieldName] - it may not have loaded yet. When it loads, call the main function.\n      if (textErrors) {\n        //console.log('textErrors: ' + textErrors + ', fieldName = ' + fieldName);\n        var fieldWatcher = scope.$watch(function() {\n          return formController[fieldName];\n        }, function(newValue) {\n          if (newValue) {\n            fieldWatcher(); // Cancel the watcher\n\n            // Do the actual thing you planned to do...\n            for (var item in textErrors) {\n              if (textErrors.hasOwnProperty(item)) {\n                toggleErrorVisibilityForTextError(errorController, formController, formController[fieldName], scope, element, textErrors[item], fieldLabel);\n              }\n            }\n          }\n        });\n      }\n\n      element.removeAttr('error-container').removeAttr('field-name').removeAttr('field-errors').removeAttr('text-errors');\n    }\n  };\n}]);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/errorMessageContainer/ErrorMessageContainer.js\n **/","import angular from 'angular';\nimport FieldErrorController from './FieldErrorController';\nimport FormControlService from './FormControlService';\nimport RequiredMarker from '../requiredMarker/RequiredMarker';\n\nconst mod = angular.module('ngFormLib.controls.common', [\n  FieldErrorController,\n  FormControlService,\n  RequiredMarker\n]);\n\nexport default mod.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/common/index.js\n **/","import angular from 'angular';\nimport Utility from '../../../common/Utility';\n\nconst mod = angular.module('ngFormLib.controls.common.formControlService', [Utility]);\n\nexport default mod.name;\n\n// Workaround for bug #1404\n// https://github.com/angular/angular.js/issues/1404\n// Source: http://plnkr.co/edit/hSMzWC?p=preview\n// Not so great for IE8, but necessary for using radio buttons inside of dynamic forms (ng-repeat)\nmod.config(['$provide', function($provide) {\n  $provide.decorator('ngModelDirective', ['$delegate', function($delegate) {\n    var ngModel = $delegate[0], controller = ngModel.controller;\n    ngModel.controller = ['$scope', '$element', '$attrs', '$injector', function(scope, element, attrs, $injector) {\n      var $interpolate = $injector.get('$interpolate');\n      attrs.$set('name', $interpolate(attrs.name || '')(scope));\n      $injector.invoke(controller, this, {\n        '$scope': scope,\n        '$element': element,\n        '$attrs': attrs\n      });\n    }];\n    return $delegate;\n  }]);\n  $provide.decorator('formDirective', ['$delegate', function($delegate) {\n    var form = $delegate[0], controller = form.controller;\n    form.controller = ['$scope', '$element', '$attrs', '$injector', function(scope, element, attrs, $injector) {\n      var $interpolate = $injector.get('$interpolate');\n      attrs.$set('name', $interpolate(attrs.name || attrs.ngForm || '')(scope));\n      $injector.invoke(controller, this, {\n        '$scope': scope,\n        '$element': element,\n        '$attrs': attrs\n      });\n    }];\n    return $delegate;\n  }]);\n}]);\n\n\n// Shared code for the accessible controls\nmod.provider('formControlService', function() {\n  var self = this,\n      counter = 0;    // Private variable\n\n  //\n  self.defaults = {\n    idPrefix: 'fpFld',\n    templates: {\n      formCheckbox: {\n        template:           require('file?name=/template/[name].[ext]!../formCheckbox/template/FormCheckboxTemplate.tpl.html')\n      },\n      formDate: {\n        template:           require('file?name=/template/[name].[ext]!../formDate/template/FormDateInputTemplate.tpl.html')\n      },\n      formInput: {\n        template:           require('file?name=/template/[name].[ext]!../formInput/template/FormInputTemplate.tpl.html')\n      },\n      formRadioButton: {\n        template:           require('file?name=/template/[name].[ext]!../formRadioButton/template/FormRadioButtonTemplate.tpl.html')\n      },\n      formSelect: {\n        template:           require('file?name=/template/[name].[ext]!../formSelect/template/FormSelectTemplate.tpl.html')\n      },\n      requiredMarker: {\n        template:           require('file?name=/template/[name].[ext]!../requiredMarker/template/RequiredMarkerTemplate.tpl.html')\n      }\n    }\n  };\n\n  this.$get = ['ngFormLibStringUtil', '$interpolate', function(StringUtil) {\n\n    var service = {\n      defaults: self.defaults,\n\n      buildDirective: function(params) {\n        var directive = {\n          restrict: 'AE',\n          replace: true,\n          transclude: true,\n          compile: function(tElement, tAttr) {\n\n            service.validateComponentStructure(params.controlName, tElement, params.expectedTemplateElements, tAttr, params.expectedAttributes);\n\n            // For items that are inside repeaters, if more than one element has the same id, the checkbox stops working.\n            // By using an attribute that is not called 'id', we can avoid this issue\n            var id = tAttr.uid || service.getUniqueFieldId(),\n              name = tAttr.name || id,// Doing this *will* break radio buttons, but they SHOULD provide a name anyway (for their own good)\n              inputElem = tElement.find(params.inputElementName || 'input'),\n              labelElem = tElement.find('label'),\n              required = service.getRequiredAttribute(tAttr.required);\n\n            service.decorateLabel(labelElem, required, id, tAttr.labelClass, tAttr.hideLabel, tAttr.hideRequiredIndicator, tAttr.labelSuffix);\n            inputElem = service.decorateInputField(inputElem, tElement, tAttr, id, name, required);\n\n            // Do component-specific config last\n            params.configFn(tElement, tAttr, id, name, inputElem, labelElem);\n\n            // Clean up special attributes (to make HTML look nicer)\n            tElement.removeAttr('uid').removeAttr('name').removeAttr('label').removeAttr('required').removeAttr('field-hint')\n              .removeAttr('input-type').removeAttr('hide-label').removeAttr('hideRequiredIndicator')\n              .removeAttr('label-class').removeAttr('field-errors').removeAttr('text-errors');\n          },\n          templateUrl: function(element, attr) {\n            // Check the element for a \"template\" attribute, which allows customisation-per-control. Otherwise, use the control-wide template.\n            return attr.template || service.getHTMLTemplate(element, params.controlName);\n          }\n        };\n\n        return directive;\n      },\n\n      getUniqueFieldId: function() {\n        return '' + self.defaults.idPrefix + counter++;\n      },\n\n      getHTMLTemplate: function(element, type) {\n        // Allow different templates to be applied for different form-styles (eg for horizontal forms, inline forms, \"normal\" forms).\n        // This is an advanced feature that most users will not need.\n        // E.g.: self.defaults.templates['select']['form-inline'] = 'path/to/your/custom/template.html'\n\n        // Check this element's parent-form-element-classes to see if they match. First match, wins.\n        var parentFormClasses = (element.inheritedData('formElementClasses') || '').split(' ');\n        var result = self.defaults.templates[type].template;  // The default template, if nothing else is specified.\n\n        for (var i = 0; i < parentFormClasses.length; i++) {\n          var template = self.defaults.templates[type][parentFormClasses[i]];\n          if (template) {\n            result = template;\n            break;\n          }\n        }\n\n        return result;\n      },\n\n      addToAttribute: function(element, attributeName, value) {\n        var existingVal = element.attr(attributeName);\n        element.attr(attributeName, ((existingVal) ? existingVal + ' ' : '') + value);\n      },\n\n\n      removeFromAttribute: function(element, attributeName, value) {\n        // Borrowed this statement from Angular.js\n        var newValue = StringUtil.trim(\n          (' ' + (element.attr(attributeName) || '') + ' ')\n          .replace(/[\\n\\t]/g, ' ')\n          .replace(' ' + StringUtil.trim(value) + ' ', ' ')\n        );\n\n        // Remove the attribute if it is empty\n        if (newValue === '') {\n          element.removeAttr(attributeName);\n        } else {\n          element.attr(attributeName, newValue);\n        }\n      },\n\n\n      getRequiredAttribute: function(required) {\n        // When we set required=\"true\" on a parent directive (like on-off-button), inputElem.attr('required', 'true')\n        // becomes <input required=\"required\" due to browser interference. So detect this case, and replace it with \"true\"\n        // In v1.3, required=\"true\" becomes required=\"\".\n        if (required === 'required' || required === '' || required === 'true') {\n          return 'true';\n        } else if (required === undefined) {\n          return 'false';\n        }\n        return required;\n      },\n\n\n      decorateLabel: function(labelElem, required, id, labelClass, hideLabelExpr, hideRequiredIndicator, labelSuffix) {\n        if (id) {\n          labelElem.attr('for', id);\n        }\n        if (labelClass) {\n          labelElem.addClass(labelClass);\n        }\n        if (hideLabelExpr) {\n          labelElem.attr('ng-class', '{\\'sr-only\\': ' + hideLabelExpr + '}');\n        }\n        if (!hideRequiredIndicator) {\n          labelElem.append('<span required-marker hide=\"!(' + required + ')\"></span>');\n        }\n        // Some labels have suffix text - text that helps with describing the label, but isn't really the label text.\n        // E.g. Amount ($AUD)\n        if (labelSuffix) {\n          labelElem.text(labelElem.text() + ' ' + labelSuffix);\n        }\n      },\n\n\n\n      decorateInputField: function(inputElem, hostElement, attr, id, name, required) {\n        if (attr.inputType) {\n          // inputElem.attr('type', attr.inputType); // THIS WILL NOT WORK ON IE8!\n          // Instead, we must replace the entire node with the only property which SHOULD exist on the template: 'class'\n          inputElem.replaceWith('<input type=\"' + attr.inputType + '\" class=\"' + inputElem.attr('class') + '\">');\n          inputElem = hostElement.find('input');\n        }\n\n        inputElem.attr('id', id);\n\n        // Allow the name to be interpolated\n        inputElem.attr('name', name);\n\n        // Apply all of the ff-* attributes to the input element. Use the original attribute names\n        // attr.$attr contains the snake-case names e.g. 'form-field' vs camel case 'formField'\n        for (var a in attr.$attr) {\n          if (a.indexOf('ff') === 0) {    // Don't search for 'ff-' as the '-' has been replaced with camel case now\n            var origAttrName = attr.$attr[a].substr(3);\n\n            if (origAttrName === 'class') {\n              inputElem.addClass(attr[a]);\n\n            // Special case for type property. It *must* be read-only. Therefore, don't write it to the element\n            // See http://stackoverflow.com/questions/8378563/why-cant-i-change-the-type-of-an-input-element-to-submit\n            } else if (origAttrName !== 'type') {\n              inputElem.attr(origAttrName, attr[a]);\n            }\n\n            // Remove all attributes off the host element\n            hostElement.removeAttr(attr.$attr[a]);\n          }\n        }\n\n        inputElem.attr('ng-required', required);\n        inputElem.attr('aria-required', '{{!!(' + required + ')}}');  // evaluates to true / false\n        return inputElem;\n      },\n\n\n      createErrorFeatures: function(parentElement, inputElement, name, fieldLabel, fieldErrors, textErrors) {\n        if (fieldErrors || textErrors) {\n          // Add an fieldErrorControllers attribute to the element, to hook-up the error features\n          inputElement.attr('field-error-controller', '');\n\n          var fieldLabelStr = (fieldLabel) ? ' field-label=\"' + fieldLabel + '\"' : '';\n          var errorContainerElem = angular.element('<div error-container field-name=\"' + name + '\"' + fieldLabelStr + '></div>');\n          if (fieldErrors) {\n            errorContainerElem.attr('field-errors', fieldErrors);\n          }\n          if (textErrors) {\n            errorContainerElem.attr('text-errors', textErrors);\n          }\n          parentElement.append(errorContainerElem);\n        }\n      },\n\n      createFieldHint: function(hostElement, inputElement, fieldHint, fieldHintId, fieldHintDisplay) {\n        var hintElement;\n\n        if (fieldHint) {\n          // If we have a field hint, add that as well\n          if (fieldHintDisplay) {\n            // If a field hint display rule exists, implement.\n            hintElement = angular.element('<p ng-if=\"' + fieldHintDisplay + '\" class=\"help-block\" id=\"' + fieldHintId + '\">' + fieldHint + '</p>');\n          } else {\n            hintElement = angular.element('<p class=\"help-block\" id=\"' + fieldHintId + '\">' + fieldHint + '</p>');\n          }\n          hostElement.append(hintElement);\n          inputElement.attr('aria-describedby', fieldHintId);\n        }\n      },\n\n      buildNgClassExpression: function(inputElem, targetElem) {\n        // If the inputElem has an ngModel and/or ngChecked attribute, create the ng-class attribute\n        //todo.. test checkbox implementation\n        var modelStr = inputElem.attr('ng-model'),\n            checkedStr = inputElem.attr('ng-checked'),\n            disabledStr = inputElem.attr('ng-disabled'),\n            value = inputElem.attr('value'),        // a string - used for Radio buttons\n            ngValue = inputElem.attr('ng-value'),   // an expression - used for Radio buttons\n            ngTrueValue = inputElem.attr('ng-true-value');\n\n        if (modelStr) {\n          if (ngValue || ngTrueValue) {\n            modelStr += ' === ' + (ngValue || ngTrueValue);\n          } else if (value) {\n            // The value is ALWAYS a string\n            modelStr += ' === \\'' + value + '\\'';\n          } else {\n            modelStr += ' === true';  // For checkboxes, in the absence of ng-true-value\n          }\n        }\n\n        if (modelStr && checkedStr) {\n          modelStr += ' || ' + checkedStr;\n        } else if (checkedStr) {\n          modelStr = checkedStr;\n        }\n\n        if (modelStr && disabledStr) {\n          targetElem.attr('ng-class', '{\\'checked\\': ' + modelStr + ', \\'disabled\\': ' + disabledStr + '}');\n        } else if (modelStr) {\n          targetElem.attr('ng-class', '{\\'checked\\': ' + modelStr + '}');\n        }\n      },\n\n      validateComponentStructure: function(componentName, element, requiredElements, attr, requiredAttributes) {\n        for (var i = 0; i < requiredElements.length; i++) {\n          if (!element.find(requiredElements[i])) {\n            throw new Error('The ' + componentName + ' component template requires a ' + requiredElements[i] + ' element.');\n          }\n        }\n\n        for (var j = 0; j < requiredAttributes.length; j++) {\n          if (!attr[requiredAttributes[j]]) {\n            throw new Error('The ' + componentName + ' component requires a ' + requiredAttributes[j] + ' attribute.');\n          }\n        }\n      }\n\n    };\n    return service;\n  }];\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/common/FormControlService.js\n **/","import angular from 'angular';\n\nconst mod = angular.module('ngFormLib.common.utility', []);\n\nexport default mod.name;\n\nmod.constant('ngFormLibDateUtil', {\n  convertDate: function(dateStr, newSep) {\n    // Converts a date between dd/mm/yyyy and yyyy-mm-dd\n    if (!dateStr || !newSep || !(newSep === '/' || newSep === '-')) {\n      return dateStr;\n    }\n\n    // Choose a separator string that is the 'opposite' of the desired separator\n    var oldSep = (newSep === '/') ? '-' : '/',\n      parts = dateStr.split(oldSep);\n\n    // if we get a dodgy date OR you tried to convert a date that was already in the correct format, return the input\n    if (isNaN(parts.join('')) || parts.length !== 3) {\n      return dateStr;\n    }\n\n    // Swap the year and day parts around\n    return parts[2] + newSep + parts[1] + newSep + parts[0];\n  },\n  formatDay: function(dayOrDate, month, year) {\n    var dd = dayOrDate, mm = month, yyyy = year;\n    if (dayOrDate.getUTCDay) {\n      dd = dayOrDate.getDate();\n      mm = dayOrDate.getMonth() + 1;//January is 0!`\n      yyyy = dayOrDate.getFullYear();\n    }\n    return ((dd < 10) ? '0' + dd : dd) + '/' + ((mm < 10) ? '0' + mm : mm) + '/' + yyyy;\n  },\n  dateAdd: function(dateStr, numDays) {\n    // Return a modified date in ISO format\n    var myDate = this.getDate(dateStr);\n    myDate.setDate(myDate.getDate() + numDays);\n\n    return this.formatDay(myDate);\n  },\n  getToday: function(optionalDate) {\n    return this.formatDay(optionalDate || new Date());\n  },\n  isISODate: function(dateStr) {\n    return (typeof dateStr === 'string' && dateStr.indexOf('-') > 0);\n  },\n  getDate: function(dateStr) {\n    if (!this.isISODate(dateStr)) {\n      dateStr = this.convertDate(dateStr, '-');\n    }\n    return new Date(dateStr);\n  },\n  monthsBetween: function(date1, date2) {\n    return date2.getMonth() - date1.getMonth() + (12 * (date2.getFullYear() - date1.getFullYear()));\n  }\n});\n\n\nmod.constant('ngFormLibStringUtil', (function() {\n  var trimRegExp = /^\\s+|\\s+$/g;\n\n  return {\n    trim: function(text) {\n      if (typeof text === 'string') {\n        return text.replace(trimRegExp, '');\n      }\n      return text;\n    }\n  };\n})());\n\n\nmod.constant('ngFormLibNumberUtil', (function() {\n  var isDigitsRegExp = /^\\d+$/;\n\n  return {\n    isDigits: function(text) {\n      return isDigitsRegExp.test(text);\n    }\n  };\n})());\n\n\nmod.constant('ngFormLibObjectUtil', {\n  getUniqueId: function() {\n    return ('' + (new Date()).getTime() + Math.random()).replace(/\\./, '');\n  },\n  toArray: function(obj) {\n    var arr = [];\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        arr[arr.length] = {key: i, value: obj[i]};\n      }\n    }\n    arr.sort(function compare(a, b) {\n      return a.key < b.key;\n    });\n    return arr;\n  }\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/common/Utility.js\n **/","import angular from 'angular';\nimport FormControlService from './FormControlService';\n\nconst mod = angular.module('ngFormLib.controls.common.fieldErrorController', [\n  FormControlService\n]);\n\nexport default mod.name;\n\n/**\n * The Field Error Controller directive is designed to indicate to the browser when the field is in error\n *  and what the errors are. It applies the form-policy for showing errors\n *\n * It works in tandem with the form controller (and FormPolicy.js) to identify when a form-element has an error, and decorates\n *  the element accordingly.\n *\n * It also toggles the fieldController.fieldState flag, based on the form policy provided\n *\n */\n\n// INPUT:\n//  <input ... field-error-controller></input>\n\n// OUTPUT:\n//  <input ... aria-invalid=\"false/true\" aria-describedby=\"fieldId-errors\">\n\n\nmod.directive('fieldErrorController', ['formControlService', '$timeout', function(formControlService, $timeout) {\n\n  function updateAriaFeatures(fieldState, element, formName, fieldName) {\n    element.attr('aria-invalid', fieldState === 'error');\n    var errorElemId = formName + '-' + fieldName + '-errors-aria';\n\n    if (fieldState === 'error') {\n      // Use the errorContainer's special ARIA element as the source of the error text\n      formControlService.addToAttribute(element, 'aria-describedby', errorElemId);\n    } else {\n      formControlService.removeFromAttribute(element, 'aria-describedby', errorElemId);\n    }\n  }\n\n  function updateElementStyle(fieldState, element, formPolicy) {\n    element[(fieldState === 'error') ? 'addClass' : 'removeClass'](formPolicy.fieldErrorClass);\n    element[(fieldState === 'success') ? 'addClass' : 'removeClass'](formPolicy.fieldSuccessClass);\n  }\n\n  function setupCanShowErrorPropertyOnNgModelController(scope, formController, ngModelController, element, name) {\n    // Using the form policy, determine when to show errors for this field\n    var formPolicy = formController._policy,\n      formName = formController.$name,\n      fieldName = formName + '.' + name,\n      stateConditions = formPolicy.stateDefinitions(formName, fieldName);\n\n    formPolicy.checkForStateChanges(formController._scope, element, name, stateConditions, ngModelController, formController);\n  }\n\n\n  return {\n    restrict: 'AE',\n    require: ['?ngModel', '?^form', '?^formGroup'],  // Require the formController controller somewhere in the parent hierarchy\n    replace: true,\n    link: function(scope, element, attr, controllers) {\n      // Tried to use a template string, but the model was not binding properly. Using $compile() works :)\n      var ngModelController = controllers[0],\n        formController = controllers[1],\n        formGroupElement = (controllers[2] || {}).$element || element,// This looks for a parent directive called formGroup, which has a controller, which has an $element property\n        name = attr.name;\n\n\n      if (formController) {\n        var formName = formController.$name,\n          errorBehaviour = formController._applyFormBehaviourOnStateChangePolicy; // returns a function which encapsulates the form policy rules for the behaviour to apply when errors show\n\n        if (ngModelController) {\n          setupCanShowErrorPropertyOnNgModelController(scope, formController, ngModelController, element, name);\n        }\n\n        // When the error-showing flag changes, update the field style\n        formController._scope.$watch(formName + '.' + name + '.fieldState', function(fieldState) {\n          updateAriaFeatures(fieldState, element, formName, name);\n          updateElementStyle(fieldState, formGroupElement, formController._policy);\n\n          // Apply the error behaviour behaviour\n          errorBehaviour.applyBehaviour(element, fieldState, false);\n        });\n\n        // Listen to form-submit events, to determine what to focus on too\n        scope.$on('event:FormSubmitAttempted', function() {\n          // Make sure that the field-level watchers have a chance to fire first, so use a timeout\n          $timeout(function() {\n            errorBehaviour.applyBehaviour(element, ngModelController.fieldState, true);\n          }, 1);\n        });\n      }\n    }\n  };\n}]);\n\n\n// This directive\nmod.directive('formGroup', [function() {\n  return {\n    restrict: 'AC',\n    controller: ['$scope', '$element', function($scope, $element) {\n      this.$element = $element;\n    }]\n  };\n}]);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/common/FieldErrorController.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common/index';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formCheckbox', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n\n// INPUT:\n//  <form-checkbox id=\"id\" name=\"name\" required=\"{{expression}}\"\n//      ff-class=\"span12\" ff-ng-model=\"application.contentType\" ff-value=\"software\" ff-aria-label=\"Software\"\n//        ff-ng-click=\"doSomething()\"\n//      field-errors=\"{required: 'Please select'}\"\n//      text-errors=\"['wrong value']\"\n//      >My label with <a href=\"http://www.google.com/\">HTML bits</a> in it</form-checkbox>\n\n// OUTPUT:\n\n\nmod.directive('formCheckbox', ['formControlService', function(formControlService) {\n\n  return formControlService.buildDirective({\n    controlName: 'formCheckbox',\n    expectedTemplateElements: ['input', 'label', 'div'],\n    expectedAttributes: [],\n    configFn: function(tElement, tAttr, id, name, inputElem) {\n      // Move the class attribute from the outer-DIV to the checkbox DIV (special case)\n      var checkboxDiv = tElement.find('div');\n      checkboxDiv.addClass(tElement.attr('class'));\n      tElement.removeAttr('class');\n\n      formControlService.createErrorFeatures(tElement, inputElem, name, '', tAttr.fieldErrors, tAttr.textErrors);\n      formControlService.buildNgClassExpression(inputElem, inputElem);  // Put the ng-class onto the input element itself, as this makes styling easier\n    }\n  });\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formCheckbox/FormCheckbox.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formDate', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n\n// INPUT:\n//    <div form-date id=\"toDate\" name=\"toDate\" label=\"To date\" hide-label=\"true\" input-type=\"text\"\n//    ff-ng-model=\"acctCtrl.search.toDate\" ff-max-date=\"today\" ff-bs-show=\"acctCtrl.datePickers.datePickerTo\"\n//    ff-ng-blur=\"acctCtrl.toggleDatePicker('datePickerTo', true)\"\n//    ff-ng-focus=\"acctCtrl.toggleDatePicker('datePickerFrom', true)\"\n//    ff-class=\"form-control input-beta input-date\"\n//    field-errors=\"{date: 'ERROR.DATE_INVALID'}\" >\n//      <i class=\"calendar\" ng-click=\"acctCtrl.toggleDatePicker('datePickerTo')\"></i>\n//    </div>\n\n\nmod.directive('formDate', ['formControlService', function(formControlService) {\n\n  return formControlService.buildDirective({\n    controlName: 'formDate',\n    expectedTemplateElements: ['input', 'label'],\n    expectedAttributes: ['label'],\n    configFn: function(tElement, tAttr, id, name, inputElem, labelElem) {\n      labelElem.prepend(tAttr.label);\n\n      //formControlService.decorateInputGroup(tElement.find('div'), tAttr.inputGroupClass);\n      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n      formControlService.createErrorFeatures(inputElem.parent(), inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n    }\n  });\n}]);\n\n\nmod.directive('formDateFormat', ['ngFormLibDateUtil', function(DateUtil) {\n  // All dates greater than AD 0 and less than AD 10000 in dd/mm/yyyy format\n  // RegEx behaves oddly if /g is uses in Regexp.test() situations\n  var dateRegEx = /^(((0[1-9]|[12][0-9]|3[01])([\\/])(0[13578]|10|12)([\\/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([\\/])(0[469]|11)([\\/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([\\/])(02)([\\/])(\\d{4}))|((29)(\\/)(02)([\\/])([02468][048]00))|((29)([\\/])(02)([\\/])([13579][26]00))|((29)([\\/])(02)([\\/])([0-9][0-9][0][48]))|((29)([\\/])(02)([\\/])([0-9][0-9][2468][048]))|((29)([\\/])(02)([\\/])([0-9][0-9][13579][26])))$/;\n\n  return {\n    require: 'ngModel',\n    priority: 150,    // Higher priority than ui-mask (100), so the postLink function runs last\n    link: function(scope, elem, attrs, ctrl) {\n\n\n      ctrl.$parsers.unshift(function(viewValue) {\n\n\n        // If viewValue is undefined or null, jump out\n        if (!viewValue) {\n          ctrl.$setValidity('date', true);\n          ctrl.$setValidity('minDate', true);  // Turn off the error if the date format isn't valid\n          ctrl.$setValidity('maxDate', true);  // Turn off the error if the date format isn't valid\n          return viewValue;\n        }\n\n        // If viewValue is a string of 8 digits, then convert it to dd/dd/dddd first\n        if (viewValue.length === 8 && !isNaN(viewValue * 1)) {\n          viewValue = viewValue.substr(0, 2) + '/' + viewValue.substr(2, 2) + '/' + viewValue.substr(4);\n        }\n\n        // Check that it is a valid date\n        var dateFormatValid = dateRegEx.test(viewValue) || typeof viewValue === 'undefined' || !viewValue;\n        ctrl.$setValidity('date', dateFormatValid);\n\n        //console.log('dateInput: ' + viewValue + ', ' + ctrl.$modelValue);\n\n        // If the date is valid\n        if (dateFormatValid && viewValue) {\n          var fieldDate = DateUtil.getDate(viewValue);\n          // and there is a min date, check if the value is greater than the min date\n          if (attrs.minDate) {\n            var minDate = DateUtil.getDate(attrs.minDate);\n            ctrl.$setValidity('minDate', fieldDate.getTime() >= minDate.getTime());\n          } else {\n            ctrl.$setValidity('minDate', true);\n          }\n          // and there is a max date, check if the value is less than the max date\n          if (attrs.maxDate) {\n            var maxDate;\n\n            if (attrs.maxDate === 'today') {\n              maxDate = DateUtil.getDate(DateUtil.getToday());\n            } else {\n              maxDate = DateUtil.getDate(attrs.maxDate);\n            }\n\n            ctrl.$setValidity('maxDate', fieldDate.getTime() <= maxDate.getTime());\n          } else {\n            ctrl.$setValidity('maxDate', true);\n          }\n        } else {\n          ctrl.$setValidity('minDate', true);  // Turn off the error if the date format isn't valid\n          ctrl.$setValidity('maxDate', true);  // Turn off the error if the date format isn't valid\n        }\n        return viewValue;\n      });\n\n      ctrl.$viewChangeListeners.push(function() {\n        // If there is a date-change attribute, execute it when the control is valid\n        if (attrs.dateChange && ctrl.$valid) {\n          scope.$eval(attrs.dateChange);\n        }\n      });\n    }\n  };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formDate/FormDate.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formInput', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n\n// INPUT:\n//  <form-input id=\"\" name=\"\" label=\"Last name\" required=\"{{expression}}\"\n//      ff-class=\"span12\" input-type=\"text|tel|email\" ff-ng-model=\"application.lastName\"\n//      ff-maxlength=\"40\" ff-ng-pattern=\"/^[a-zA-Z0-9 \\-.']+$/\"\n//      field-hint=\"This must be the last name of the person who originally applied for the service.\"\n//      field-errors=\"{required: 'Please enter a valid last name', pattern: 'Please enter a valid last name'}\"\n//      text-errors=\"['data.errors.']\"\n//      content-class=\"span3\"\n//      >My content</form-input>\n\n// OUTPUT:\n\n\nmod.directive('formInput', ['formControlService', function(formControlService) {\n\n  return formControlService.buildDirective({\n    controlName: 'formInput',\n    expectedTemplateElements: ['input', 'label'],\n    expectedAttributes: ['label', 'inputType'],\n    configFn: function(tElement, tAttr, id, name, inputElem, labelElem) {\n      labelElem.prepend(tAttr.label);\n      addPlaceholder(inputElem, tAttr.placeholder); // Do this to be API-compatible with the form-select control. ff-placeholder is still supported. Use one or the other.\n\n      // If the user wants to use 'input-addon-prefix' or 'input-addon-suffix', change the DOM\n      var hasInputGroup = addInputGroup(inputElem, tAttr.inputPrefix, tAttr.inputSuffix);\n      var parentElemForErrors = (hasInputGroup) ? inputElem.parent().parent() : inputElem.parent();\n\n      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n      formControlService.createErrorFeatures(parentElemForErrors, inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n    }\n  });\n}]);\n\n\nfunction addPlaceholder(inputElem, placeholderText) {\n  if (placeholderText) {\n    inputElem.attr('placeholder', placeholderText);\n  }\n}\n\n\nfunction addInputGroup(inputElem, inputGroupPrefix, inputGroupSuffix) {\n  if (inputGroupPrefix || inputGroupSuffix) {\n    inputElem.wrap('<div class=\"input-group\">');//inputElem.parent(); // This should be the 'control-row' element//wrap('<div class=\"input-group\">');\n    var wrapper = inputElem.parent();\n\n    if (inputGroupPrefix) {\n      wrapper.prepend('<span class=\"input-group-addon\">' + inputGroupPrefix + '</span>');\n    }\n    if (inputGroupSuffix) {\n      wrapper.append('<span class=\"input-group-addon\">' + inputGroupSuffix + '</span>');\n    }\n    return true;\n  }\n  return false;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formInput/FormInput.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formRadioButton', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n\n// INPUT:\n//  <form-radio-button uid=\"fld\" name=\"name\" aria-label=\"Book Type\" label-class=\"btn btn-toggle\"\n//    ff-class=\"someCSS\" ff-ng-model=\"application.bookType\" ff-value=\"Fiction\" ng-click=\"loadFiction()\" class=\"span6\">\n//     <icon class=\"icon-fiction\"></icon>Fiction\n//  </form-radio-button>\n\n// OUTPUT:\n\n\nmod.directive('formRadioButton', ['formControlService', function(formControlService) {\n\n  return formControlService.buildDirective({\n    controlName: 'formRadioButton',\n    expectedTemplateElements: ['input', 'label', 'div'],\n    expectedAttributes: [], // The template should NOT have a form-group element inside it, as this has to be specified externally (due to the group-nature of radio buttons)\n    configFn: function(tElement, tAttr, id, name, inputElem) {\n      // Move the class attribute from the outer-DIV to the radio-button DIV (special case)\n      var rbDiv = tElement.find('div');\n      rbDiv.addClass(tElement.attr('class'));\n      tElement.removeAttr('class');\n\n      formControlService.createErrorFeatures(tElement, inputElem, name, '', tAttr.fieldErrors, tAttr.textErrors);\n      formControlService.buildNgClassExpression(inputElem, inputElem);  // Put the ng-class onto the input element itself, as this makes styling easier\n    }\n  });\n\n}]);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formRadioButton/FormRadioButton.js\n **/","import angular from 'angular';\n\nconst mod = angular.module('ngFormLib.controls.formReset', []);\n\nexport default mod.name;\n\n\nmod.directive('formReset', ['$parse', function($parse) {\n\n  function resetFieldState(controlMap) {\n    // Loops through the controlMap and reset's each field's state\n    for (var item in controlMap) {\n      if (controlMap.hasOwnProperty(item)) {\n        var controlList = controlMap[item];\n        for (var j = 0, jLen = controlList.length; j < jLen; j++) {\n          var control = controlList[j].controller;\n          control.fieldState = '';\n        }\n      }\n    }\n  }\n\n\n  return {\n    restrict: 'A',\n    require: '^form',\n    link: function(scope, element, attr, controller) {\n      var ngModelGet = $parse(attr.formReset),\n          ngModelSet = ngModelGet.assign;\n\n      if (!ngModelSet) {\n        throw Error('formReset requires an assignable scope-expression. \"' + attr.formReset + '\" is un-assignable.');\n      }\n\n      // Get a copy of the data as soon as the directive is created, which is after the scope/controller has been initialised (safe)\n      var originalData = angular.copy(ngModelGet(scope));\n\n      element.on('click', function() {\n        if (typeof controller.setSubmitted === 'function') {\n          controller.setSubmitted(false);\n        }\n        // Use a *copy* of the original data, as we don't want originalData to be modified by subsequent changes to the model by the form controls\n        ngModelSet(scope, angular.copy(originalData));\n        resetFieldState(controller._controls || {});\n        controller.$setPristine();\n\n        scope.$emit('event:FormReset');\n        scope.$digest();\n      });\n    }\n  };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formReset/FormReset.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formSelect', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n// INPUT:\n//  <form-select id=\"frm-size\" name=\"bookSize\" required=\"true\" label=\"Approximate size\"\n//    ff-class=\"span12\" ff-ng-model=\"model.size\" placeholder=\"Select a size bracket\"\n//    ff-ng-options=\"option.value as option.name for option in refData.bookSizes\"\n//    field-errors=\"{required: 'Please select a size bracket'}\"\n//    text-errors=\"['data.errors']\"></form-select>\n\n// OUTPUT:\n\n\n\nmod.directive('formSelect', ['formControlService', function(formControlService) {\n\n  function addPlaceholder(selectElem, placeholderText) {\n    if (placeholderText) {\n      selectElem.append('<option translate value=\"\">' + placeholderText + '</option>');\n    }\n  }\n\n  return formControlService.buildDirective({\n    controlName: 'formSelect',\n    inputElementName: 'select',\n    expectedTemplateElements: ['select', 'label'],\n    expectedAttributes: ['label'],\n    configFn: function(tElement, tAttr, id, name, inputElem, labelElem) {\n      labelElem.prepend(tAttr.label);\n      addPlaceholder(inputElem, tAttr.placeholder);  // Adds the extra option element to the start of the <option>\n\n      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n      formControlService.createErrorFeatures(inputElem.parent(), inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n    }\n  });\n\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formSelect/FormSelect.js\n **/","import angular from 'angular';\n\nconst mod = angular.module('ngFormLib.controls.formSubmit', []);\n\nexport default mod.name;\n\n\n/**\n *  formSubmit - Executes an expression when the form is valid (essentially a form.submit() handler).\n *\n *  It can be applied to either the form element or to a button.\n *\n */\nmod.directive('formSubmit', ['$parse', function($parse) {\n  return {\n    restrict: 'A',\n    require: ['^form'],   // Get the form controller\n    link: function(scope, element, attr, controller) {\n\n      var fn = $parse(attr.formSubmit) || angular.noop,\n        isForm = element[0].tagName === 'FORM',\n        formController = controller[0];\n\n      element.bind(isForm ? 'submit' : 'click', function(event) {\n\n        formController.setSubmitted(true);\n\n        scope.$apply(function() {\n          //scope.$emit('event:FormSubmitAttempted');\n\n          if (formController.$valid) {\n            if (fn(scope, {$event: event}) !== false) {\n              // Needed by the tracking tool as it clears the input data after a submission.\n              // Potentially, form field validation to be done here, but unnecessary at the moment.\n              // The reset behaviour can be over-ridden by returning false from the called function(maybe prevent default aswell?)\n              formController.setSubmitted(false);\n              formController.$setPristine();\n            }\n\n          } else {\n            event.preventDefault();\n          }\n        });\n      });\n    }\n  };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formSubmit/FormSubmit.js\n **/","import angular from 'angular';\nimport ErrorMessageContainer from './errorMessageContainer/ErrorMessageContainer';\nimport FormCheckbox from './formCheckbox/FormCheckbox';\nimport FormDate from './formDate/FormDate';\nimport FormInput from './formInput/FormInput';\nimport FormRadioButton from './formRadioButton/FormRadioButton';\nimport FormReset from './formReset/FormReset';\nimport FormSelect from './formSelect/FormSelect';\nimport FormSubmit from './formSubmit/FormSubmit';\n\n  // We need the utility module for the ngFormLibDateUtil.getDate() method for the formDateFormat directive, and ngFormLibStringUtil.trim() in controls.common\nconst mod = angular.module('ngFormLib.controls', [\n  ErrorMessageContainer,\n  FormCheckbox,\n  FormDate,\n  FormInput,\n  FormRadioButton,\n  FormReset,\n  FormSelect,\n  FormSubmit\n]);\n\nexport default mod.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/index.js\n **/","import angular from 'angular';\nimport FormControlService from '../common/FormControlService';\n\nconst mod = angular.module('ngFormLib.controls.requiredMarker', [FormControlService]);\n\nexport default mod.name;\n\n\n// Add a simple \"required\" marker that is not read-out by screen readers (as the field should also have a required indicator)\n//\n// INPUT:\n//  <span required-marker></span>\n//  <span required-marker hide=\"isNotRequired\">Some Text</span>\n\n// OUTPUT:\n//  <span class=\"required\" aria-hidden=\"true\" ng-class=\"{\\'ng-hide\\': hide}\" ng-transclude=\"\"></span>\n//  <span class=\"required\" aria-hidden=\"true\" ng-class=\"{\\'ng-hide\\': hide}\" ng-transclude=\"\" hide=\"isNotRequired\">Some Text</span>\n\nmod.directive('requiredMarker', ['formControlService', function(formControlService) {\n\n  return {\n    restrict: 'AE',\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attr) {\n      return attr.template || formControlService.getHTMLTemplate(element, 'requiredMarker');\n    },\n    scope: {\n      hide: '='\n    }\n  };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/requiredMarker/RequiredMarker.js\n **/","import angular from 'angular';\nimport angularAnimate from 'angular-animate';\nimport FormPolicy from './policy/FormPolicy';\nimport FormControls from './controls';\n\nconst mod = angular.module('ngFormLib', [angularAnimate,\n  FormPolicy,\n//    Add the policies you want, or define your own:\n//    'ngFormLib.policy.checkForStateChanges',\n//    'ngFormLib.policy.displayError',\n//    'ngFormLib.policy.focusBehaviour',\n  FormControls\n]);\n\nexport default mod.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/index.js\n **/","import angular from 'angular';\n\n// The form policy intentionally has no hard dependencies.\n// If there are form-policy values that exist when the service is being constructed, it will use them.\n// Otherwise it will use no-op policy functions.\nconst mod = angular.module('ngFormLib.policy', []);\n\nexport default mod.name;\n\n\n// This is a configurable service\n// It should contain the _default_ values for form policies\n\nmod.provider('formPolicyService', function() {\n  var self = this,\n    noop = angular.noop,\n    nullBehaviourOnStateChange = function() {\n      return {\n        applyBehaviour: noop,\n        resetBehaviour: noop\n      };\n    },\n    nullStateChanges = function() {\n      return {};\n    };\n\n  self.defaults = {\n    formSubmitAttemptedClass: 'form-submit-attempted',\n    fieldErrorClass: 'has-error',\n    fieldSuccessClass: 'has-success',\n    behaviourOnStateChange: null,    // Previously called focusBehavior\n    checkForStateChanges: null,\n    stateDefinitions: null,\n    fieldFocusScrollOffset: 0\n  };\n\n  this.$get = ['$injector', function($injector) {\n\n    function getService(name) {\n      try {\n        return $injector.get(name);\n      } catch (e) {\n        return null;    // Provider-not-found error, ignore and move on\n      }\n    }\n\n    // Policy precedence: this.defaults, policy-value-object, noop\n    self.defaults.behaviourOnStateChange = self.defaults.behaviourOnStateChange || getService('formPolicyBehaviourOnStateChange') || nullBehaviourOnStateChange;\n    self.defaults.checkForStateChanges = self.defaults.checkForStateChanges || getService('formPolicyCheckForStateChanges') || noop;\n    self.defaults.stateDefinitions = self.defaults.stateDefinitions || getService('formPolicyStateDefinitions') || nullStateChanges;\n\n    var policyService = {\n      getCurrentPolicy: function() {\n        return angular.copy(self.defaults);\n      }\n    };\n\n    return policyService;\n  }];\n});\n\n\nfunction formDirective(formPolicyService) {\n\n  return {\n    //priority: -1,\n    restrict: 'AE',\n    require: ['?form'], // Tells the directive to get the controller for the 'form' directive, which is the FormController controller\n    compile: function(tElement, tAttr) {\n\n      // Use element.data() to store a reference to this element for use by child.inheritedData()\n      // Will storing an element this way cause a memory leak? Or should I just store the data I currently need (attr.class)\n      // This has to happen during the compile step, as the children need access to the variable when they are compiled\n      //  ('class' is a reserved word to JavaScript, so we need to treat it as a string)\n      tElement.data('formElementClasses', tAttr['class']);  //jscs:ignore\n\n      return {\n        pre: function(scope, element, attr, controller) {\n          // We want to extend the FormController by adding a form policy\n          var formController = controller[0];\n          formController._policy = angular.extend(formPolicyService.getCurrentPolicy(), scope.$eval(attr.formPolicy));\n\n          // Add a reference to the <form> element's scope to the formController, to support showing errors for nested components\n          formController._scope = scope;\n\n          // Determine if we have a parent form controller. If we do, we want to use it for the focus behaviour\n          formController._parentController = element.parent().controller('form');\n\n          if (!formController._parentController) {\n            // We also want to add an element reference when a control is added\n            formController._controls = {};\n          }\n\n          // Generate the focus policy function for use by other directive\n          formController._applyFormBehaviourOnStateChangePolicy = formController._policy.behaviourOnStateChange(formController);\n\n          // Add/remove a class onto the form based on the value of the formSubmitted variable\n          formController.setSubmitted = function(value, tellNoOne) {\n            element[value ? 'addClass' : 'removeClass'](formController._policy.formSubmitAttemptedClass);\n            formController._formSubmitAttempted = value;\n            formController._applyFormBehaviourOnStateChangePolicy.resetBehaviour();\n\n            if (value && !tellNoOne) {\n              scope.$broadcast('event:FormSubmitAttempted');\n            }\n          };\n\n          // Flag to indicate whether the form has been submitted\n          formController._formSubmitAttempted = false;\n          formController._applyFormBehaviourOnStateChangePolicy.resetBehaviour();\n\n          // If this form is an ngForm (in that it has a parent 'form'), then we need to make sure that\n          // when the parent form is submitted or reset, the same thing happens to the child forms\n          if (formController._parentController) {\n            scope.$watch(function() { return formController._parentController._formSubmitAttempted; }, function(value) {\n              if (value !== undefined) {\n                //formController.setSubmitted(!!value, true);  // Don't send another notification, just update our own state\n                formController.setSubmitted(!!value);  // Don't send another notification, just update our own state\n              }\n            });\n          }\n        }\n      };\n    }\n  };\n}\nmod.directive('form', ['formPolicyService', formDirective]);\nmod.directive('ngForm', ['formPolicyService', formDirective]);\n\n\n// We want our formController to expose the list of controls that are registered with the form,\n// including controls inside sub-forms. That allows us to reset them directly. Relying simply on the fieldName\n// does not work when using sub-forms inside ng-repeaters.\n\nvar inputElements = ['input', 'select'];\n\nangular.forEach(inputElements, function(inputElem) {\n  mod.directive(inputElem, function() {\n\n    function hookupElementToNameToElementMap(formController, element, fieldName, fieldController) {\n      // Each element in the map is an array, because form elements *can have the same name*!\n      var map = formController._controls;\n      if (!map[fieldName]) {\n        map[fieldName] = [];\n      }\n      // Add the field to the end of the list of items with the same name\n      map[fieldName][map[fieldName].length] = {'element': element, 'controller': fieldController};\n\n\n      element.on('$destroy', function() {\n        // Delete just this element from the map of controls\n        var map = formController._controls[element.attr('name')];\n        var elementId = element.attr('id');\n        for (var i = 0; i < map.length; i++) {\n          if (map[i].element.attr('id') === elementId) {\n            map.splice(i, 1);\n            break;\n          }\n        }\n      });\n    }\n\n    return {\n      restrict: 'E',\n      require: ['?^form', '?ngModel'],\n      link: {\n        pre: function(scope, element, attr, controllers) {\n          if (!controllers[0]) {\n            return;\n          }\n\n          var rootFormController = controllers[0]._parentController || controllers[0],\n              fieldController = controllers[1],\n              name = attr.name;\n\n          if (rootFormController && rootFormController._controls) {\n            hookupElementToNameToElementMap(rootFormController, element, name, fieldController);\n          }\n        }\n      }\n    };\n  });\n});\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/policy/FormPolicy.js\n **/","module.exports = __webpack_public_path__ + \"/template/FormCheckboxTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formCheckbox/template/FormCheckboxTemplate.tpl.html\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"/template/FormDateInputTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formDate/template/FormDateInputTemplate.tpl.html\n ** module id = 23\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"/template/FormInputTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formInput/template/FormInputTemplate.tpl.html\n ** module id = 24\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"/template/FormRadioButtonTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formRadioButton/template/FormRadioButtonTemplate.tpl.html\n ** module id = 25\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"/template/FormSelectTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formSelect/template/FormSelectTemplate.tpl.html\n ** module id = 26\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"/template/RequiredMarkerTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/requiredMarker/template/RequiredMarkerTemplate.tpl.html\n ** module id = 27\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_28__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular-animate\"\n ** module id = 28\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_30__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular-translate\"\n ** module id = 30\n ** module chunks = 0\n **/"],"sourceRoot":""}