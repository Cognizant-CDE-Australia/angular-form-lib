{"version":3,"sources":["webpack:///js/ngFormLib.8d85ed5f.js","webpack:///./modules/ngFormLib/controls/errorMessageContainer/ErrorMessageContainer.js?4ccb","webpack:///./modules/ngFormLib/controls/common/index.js?dc60","webpack:///./modules/ngFormLib/controls/common/FormControlService.js?b2d7","webpack:///./modules/common/Utility.js?f4cc","webpack:///./modules/ngFormLib/controls/common/FieldErrorController.js?1c76","webpack:///./modules/ngFormLib/controls/formCheckbox/FormCheckbox.js?1786","webpack:///./modules/ngFormLib/controls/formDate/FormDate.js?fcc1","webpack:///./modules/ngFormLib/controls/formInput/FormInput.js?bdd1","webpack:///./modules/ngFormLib/controls/formRadioButton/FormRadioButton.js?adf1","webpack:///./modules/ngFormLib/controls/formReset/FormReset.js?9e6d","webpack:///./modules/ngFormLib/controls/formSelect/FormSelect.js?7430","webpack:///./modules/ngFormLib/controls/formSubmit/FormSubmit.js?1552","webpack:///./modules/ngFormLib/controls/index.js?3961","webpack:///./modules/ngFormLib/controls/requiredMarker/RequiredMarker.js?519f","webpack:///./modules/ngFormLib/index.js?c7c9","webpack:///./modules/ngFormLib/policy/FormPolicy.js?76b2","webpack:///./modules/ngFormLib/controls/formCheckbox/template/FormCheckboxTemplate.tpl.html?5e3e","webpack:///./modules/ngFormLib/controls/formDate/template/FormDateInputTemplate.tpl.html?6e71","webpack:///./modules/ngFormLib/controls/formInput/template/FormInputTemplate.tpl.html?4622","webpack:///./modules/ngFormLib/controls/formRadioButton/template/FormRadioButtonTemplate.tpl.html?09b3","webpack:///./modules/ngFormLib/controls/formSelect/template/FormSelectTemplate.tpl.html?e80a","webpack:///./modules/ngFormLib/controls/requiredMarker/template/RequiredMarkerTemplate.tpl.html?1b8c"],"names":["webpackJsonp","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_angular","_angular2","_angularTranslate","_angularTranslate2","mod","name","directive","$compile","$filter","translateError","errorMessage","fieldLabel","firstLetterIsAVowel","indexOf","toLowerCase","undefined","pronoun","ErrorController","element","errors","ariaElement","addError","errorType","removeError","refreshErrorText","str","i","type","hasOwnProperty","text","generateErrorTag","errorText","toggleErrorVisibilityOnError","controller","formController","scope","watchExpr","_scope","$watch","newValue","val","append","removeErrorMessage","toggleErrorVisibilityForTextError","errorController","fieldController","$setValidity","setSubmitted","$viewChangeListeners","push","$eval","divs","find","len","length","eq","hasClass","remove","restrict","require","template","replace","link","attr","controllers","fieldName","formName","$name","formField","fieldErrors","textErrors","error","errorShowCondition","fieldWatcher","item","removeAttr","_FieldErrorController","_FieldErrorController2","_FormControlService","_FormControlService2","_RequiredMarker","_RequiredMarker2","_Utility","_Utility2","config","$provide","decorator","$delegate","ngModel","attrs","$injector","$interpolate","get","$set","invoke","this","$scope","$element","$attrs","form","ngForm","provider","self","counter","defaults","idPrefix","templates","formCheckbox","formDate","formInput","formRadioButton","formSelect","requiredMarker","$get","StringUtil","service","buildDirective","params","transclude","compile","tElement","tAttr","validateComponentStructure","controlName","expectedTemplateElements","expectedAttributes","id","uid","getUniqueFieldId","inputElem","inputElementName","labelElem","required","getRequiredAttribute","decorateLabel","labelClass","hideLabel","hideRequiredIndicator","labelSuffix","decorateInputField","configFn","templateUrl","getHTMLTemplate","parentFormClasses","inheritedData","split","result","addToAttribute","attributeName","existingVal","removeFromAttribute","trim","hideLabelExpr","addClass","hostElement","inputType","replaceWith","a","$attr","origAttrName","substr","createErrorFeatures","parentElement","inputElement","fieldLabelStr","errorContainerElem","createFieldHint","fieldHint","fieldHintId","fieldHintDisplay","hintElement","buildNgClassExpression","targetElem","modelStr","checkedStr","disabledStr","ngValue","ngTrueValue","componentName","requiredElements","requiredAttributes","Error","j","constant","convertDate","dateStr","newSep","oldSep","parts","isNaN","join","formatDay","dayOrDate","month","year","dd","mm","yyyy","getUTCDay","getDate","getMonth","getFullYear","dateAdd","numDays","myDate","setDate","getToday","optionalDate","Date","isISODate","monthsBetween","date1","date2","trimRegExp","isDigitsRegExp","isDigits","test","getUniqueId","getTime","Math","random","toArray","arr","key","sort","b","formControlService","$timeout","updateAriaFeatures","fieldState","errorElemId","updateElementStyle","formPolicy","fieldErrorClass","fieldSuccessClass","setupCanShowErrorPropertyOnNgModelController","ngModelController","_policy","stateConditions","stateDefinitions","checkForStateChanges","formGroupElement","errorBehaviour","_applyFormBehaviourOnStateChangePolicy","applyBehaviour","$on","_index","_index2","_ErrorMessageContainer","_ErrorMessageContainer2","checkboxDiv","_common","_common2","prepend","label","parent","DateUtil","dateRegEx","priority","elem","ctrl","$parsers","unshift","viewValue","dateFormatValid","fieldDate","minDate","maxDate","dateChange","$valid","addPlaceholder","placeholderText","addInputGroup","inputGroupPrefix","inputGroupSuffix","wrap","wrapper","placeholder","hasInputGroup","inputPrefix","inputSuffix","parentElemForErrors","rbDiv","$parse","resetFieldState","controlMap","controlList","jLen","control","ngModelGet","formReset","ngModelSet","assign","originalData","copy","on","_controls","$setPristine","$emit","$digest","selectElem","fn","formSubmit","noop","isForm","tagName","bind","event","$apply","$event","preventDefault","_FormCheckbox","_FormCheckbox2","_FormDate","_FormDate2","_FormInput","_FormInput2","_FormRadioButton","_FormRadioButton2","_FormReset","_FormReset2","_FormSelect","_FormSelect2","_FormSubmit","_FormSubmit2","hide","_angularAnimate","_angularAnimate2","_FormPolicy","_FormPolicy2","_controls2","formDirective","formPolicyService","data","pre","extend","getCurrentPolicy","_parentController","behaviourOnStateChange","tellNoOne","formSubmitAttemptedClass","_formSubmitAttempted","resetBehaviour","$broadcast","nullBehaviourOnStateChange","nullStateChanges","fieldFocusScrollOffset","getService","e","policyService","inputElements","forEach","hookupElementToNameToElementMap","map","elementId","splice","rootFormController","p"],"mappings":"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","file":"js/ngFormLib.8d85ed5f.js","sourcesContent":["webpackJsonp([2],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(18);\n\n\n/***/ },\n/* 1 */,\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularTranslate = __webpack_require__(5);\n\t\n\tvar _angularTranslate2 = _interopRequireDefault(_angularTranslate);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.errorMessageContainer', [_angularTranslate2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t//angular.module('ngFormLib.controls.errorMessageContainer', ['pascalprecht.translate'])\n\t\n\t/**\n\t * This directive is really a FIELD error message container - it is designed to work with fields exclusively\n\t */\n\t\n\tmod.directive('errorContainer', ['$compile', '$filter', function ($compile, $filter) {\n\t\n\t  function translateError(errorMessage, fieldLabel) {\n\t    var firstLetterIsAVowel = fieldLabel ? 'aeiou'.indexOf(fieldLabel[0].toLowerCase()) !== -1 : undefined;\n\t    return $filter('translate')(errorMessage, { pronoun: firstLetterIsAVowel ? 'an' : 'a', fieldLabel: fieldLabel });\n\t  }\n\t\n\t  function ErrorController(element) {\n\t    var errors = [],\n\t        ariaElement = element;\n\t\n\t    return {\n\t      addError: function addError(errorType, errorMessage, fieldLabel) {\n\t        errors[errorType] = translateError(errorMessage, fieldLabel);\n\t      },\n\t\n\t      removeError: function removeError(errorType) {\n\t        delete errors[errorType];\n\t      },\n\t\n\t      refreshErrorText: function refreshErrorText() {\n\t        var str = '',\n\t            i = 0;\n\t        for (var type in errors) {\n\t          if (errors.hasOwnProperty(type)) {\n\t            str += 'Error ' + ++i + ', ' + errors[type] + ',';\n\t          }\n\t        }\n\t\n\t        if (i === 1) {\n\t          str = '. There is 1 error for this field. ' + str;\n\t        } else if (i > 1) {\n\t          str = '. There are ' + i + ' errors for this field. ' + str;\n\t        }\n\t        ariaElement.text(str);\n\t      }\n\t    };\n\t  }\n\t\n\t  function generateErrorTag(errorType, errorText, fieldLabel) {\n\t    return '<div class=\"text-error ec2-' + errorType + '\"><span class=\"text-error-wrap\">' + translateError(errorText, fieldLabel) + '</span></div>';\n\t  }\n\t\n\t  /**\n\t   * Handle the field-based error messages\n\t   */\n\t  function toggleErrorVisibilityOnError(controller, formController, scope, element, watchExpr, errorType, errorText, fieldLabel) {\n\t    //console.log('watchExpr = ' + watchExpr);\n\t    formController._scope.$watch(watchExpr, function (newValue) {\n\t      if (newValue) {\n\t        // The error text could contain an interpolation string, so we need to compile it\n\t        var val = $compile(generateErrorTag(errorType, errorText, fieldLabel))(scope);\n\t        element.append(val);\n\t        controller.addError(errorType, errorText, fieldLabel);\n\t      } else {\n\t        removeErrorMessage(controller, formController, element, errorType);\n\t      }\n\t      controller.refreshErrorText();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Handle text errors. Text errors are associated with a scope, rather than with a field.\n\t   * This means we can clear them from the scope when the field-they-are-associated-with is changed.\n\t   */\n\t  function toggleErrorVisibilityForTextError(errorController, formController, fieldController, scope, element, watchExpr, fieldLabel) {\n\t    //console.log('Watching error: ' + watchExpr);\n\t\n\t    formController._scope.$watch(watchExpr, function (newValue) {\n\t      // Update the validity of the field's \"watchExpr\" error-key to match the value of the errorText\n\t      fieldController.$setValidity(watchExpr, !newValue);\n\t\n\t      // Remove the old error message for this same errorType first, in cases where the error message is changing.\n\t      removeErrorMessage(errorController, formController, element, watchExpr);\n\t\n\t      if (newValue) {\n\t        // No need to compile the error message as we already have its value\n\t        element.append(generateErrorTag(watchExpr, newValue, fieldLabel));\n\t        errorController.addError(watchExpr, newValue, fieldLabel);\n\t\n\t        // Turn the border red by sending a 'form-submit-attempted' event\n\t        formController.setSubmitted(true);\n\t      }\n\t      errorController.refreshErrorText();\n\t    });\n\t\n\t    // When the field changes, clear the errorText value\n\t    fieldController.$viewChangeListeners.push(function () {\n\t      if (scope.$eval(watchExpr)) {\n\t        scope.$eval(watchExpr + ' = null');\n\t      }\n\t    });\n\t  }\n\t\n\t  function removeErrorMessage(controller, formController, element, errorType) {\n\t    // find the div with our special class, then remove it\n\t    var divs = element.find('div');\n\t    for (var len = divs.length, i = len - 1; i > -1; i--) {\n\t      if (divs.eq(i).hasClass('ec2-' + errorType)) {\n\t        divs.eq(i).remove();\n\t      }\n\t    }\n\t    controller.removeError(errorType);\n\t  }\n\t\n\t  return {\n\t    restrict: 'AE',\n\t    require: ['^form'], // Require the formController controller somewhere in the parent hierarchy (mandatory for field-errors)\n\t    template: '<div class=\"container-error\"></div>',\n\t    replace: true,\n\t    link: function link(scope, element, attr, controllers) {\n\t\n\t      var fieldName = attr.fieldName,\n\t          fieldLabel = attr.fieldLabel || '',\n\t          formController = controllers[0],\n\t          formName = formController.$name,\n\t          formField = formName + '.' + fieldName,\n\t          fieldErrors = scope.$eval(attr.fieldErrors || []),\n\t          // You can escape interpolation brackets inside strings by doing  \\{\\{   - wow!\n\t      textErrors = scope.$eval(attr.textErrors || []);\n\t\n\t      element.attr('id', formName + '-' + fieldName + '-errors');\n\t      element.append('<span class=\"sr-only\" aria-hidden=\"true\" id=\"' + formName + '-' + fieldName + '-errors-aria\"></span>');\n\t\n\t      var ariaElement = element.find('span'),\n\t          errorController = new ErrorController(ariaElement); // new? Maybe make this the directive's controller instead\n\t\n\t      for (var error in fieldErrors) {\n\t        if (fieldErrors.hasOwnProperty(error)) {\n\t          var errorShowCondition = formField + '.fieldState === \"error\" && ' + formField + '.$error.' + error;\n\t          toggleErrorVisibilityOnError(errorController, formController, scope, element, errorShowCondition, error, fieldErrors[error], fieldLabel);\n\t        }\n\t      }\n\t\n\t      // Watch formController[fieldName] - it may not have loaded yet. When it loads, call the main function.\n\t      if (textErrors) {\n\t        //console.log('textErrors: ' + textErrors + ', fieldName = ' + fieldName);\n\t        var fieldWatcher = scope.$watch(function () {\n\t          return formController[fieldName];\n\t        }, function (newValue) {\n\t          if (newValue) {\n\t            fieldWatcher(); // Cancel the watcher\n\t\n\t            // Do the actual thing you planned to do...\n\t            for (var item in textErrors) {\n\t              if (textErrors.hasOwnProperty(item)) {\n\t                toggleErrorVisibilityForTextError(errorController, formController, formController[fieldName], scope, element, textErrors[item], fieldLabel);\n\t              }\n\t            }\n\t          }\n\t        });\n\t      }\n\t\n\t      element.removeAttr('error-container').removeAttr('field-name').removeAttr('field-errors').removeAttr('text-errors');\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _FieldErrorController = __webpack_require__(8);\n\t\n\tvar _FieldErrorController2 = _interopRequireDefault(_FieldErrorController);\n\t\n\tvar _FormControlService = __webpack_require__(4);\n\t\n\tvar _FormControlService2 = _interopRequireDefault(_FormControlService);\n\t\n\tvar _RequiredMarker = __webpack_require__(17);\n\t\n\tvar _RequiredMarker2 = _interopRequireDefault(_RequiredMarker);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.common', [_FieldErrorController2.default, _FormControlService2.default, _RequiredMarker2.default]);\n\t\n\texports.default = mod.name;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _Utility = __webpack_require__(7);\n\t\n\tvar _Utility2 = _interopRequireDefault(_Utility);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.common.formControlService', [_Utility2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// Workaround for bug #1404\n\t// https://github.com/angular/angular.js/issues/1404\n\t// Source: http://plnkr.co/edit/hSMzWC?p=preview\n\t// Not so great for IE8, but necessary for using radio buttons inside of dynamic forms (ng-repeat)\n\t\n\tmod.config(['$provide', function ($provide) {\n\t  $provide.decorator('ngModelDirective', ['$delegate', function ($delegate) {\n\t    var ngModel = $delegate[0],\n\t        controller = ngModel.controller;\n\t    ngModel.controller = ['$scope', '$element', '$attrs', '$injector', function (scope, element, attrs, $injector) {\n\t      var $interpolate = $injector.get('$interpolate');\n\t      attrs.$set('name', $interpolate(attrs.name || '')(scope));\n\t      $injector.invoke(controller, this, {\n\t        '$scope': scope,\n\t        '$element': element,\n\t        '$attrs': attrs\n\t      });\n\t    }];\n\t    return $delegate;\n\t  }]);\n\t  $provide.decorator('formDirective', ['$delegate', function ($delegate) {\n\t    var form = $delegate[0],\n\t        controller = form.controller;\n\t    form.controller = ['$scope', '$element', '$attrs', '$injector', function (scope, element, attrs, $injector) {\n\t      var $interpolate = $injector.get('$interpolate');\n\t      attrs.$set('name', $interpolate(attrs.name || attrs.ngForm || '')(scope));\n\t      $injector.invoke(controller, this, {\n\t        '$scope': scope,\n\t        '$element': element,\n\t        '$attrs': attrs\n\t      });\n\t    }];\n\t    return $delegate;\n\t  }]);\n\t}]);\n\t\n\t// Shared code for the accessible controls\n\tmod.provider('formControlService', function () {\n\t  var self = this,\n\t      counter = 0; // Private variable\n\t\n\t  //\n\t  self.defaults = {\n\t    idPrefix: 'fpFld',\n\t    templates: {\n\t      formCheckbox: {\n\t        template: __webpack_require__(20)\n\t      },\n\t      formDate: {\n\t        template: __webpack_require__(21)\n\t      },\n\t      formInput: {\n\t        template: __webpack_require__(22)\n\t      },\n\t      formRadioButton: {\n\t        template: __webpack_require__(23)\n\t      },\n\t      formSelect: {\n\t        template: __webpack_require__(24)\n\t      },\n\t      requiredMarker: {\n\t        template: __webpack_require__(25)\n\t      }\n\t    }\n\t  };\n\t\n\t  this.$get = ['ngFormLibStringUtil', '$interpolate', function (StringUtil) {\n\t\n\t    var service = {\n\t      defaults: self.defaults,\n\t\n\t      buildDirective: function buildDirective(params) {\n\t        var directive = {\n\t          restrict: 'AE',\n\t          replace: true,\n\t          transclude: true,\n\t          compile: function compile(tElement, tAttr) {\n\t\n\t            service.validateComponentStructure(params.controlName, tElement, params.expectedTemplateElements, tAttr, params.expectedAttributes);\n\t\n\t            // For items that are inside repeaters, if more than one element has the same id, the checkbox stops working.\n\t            // By using an attribute that is not called 'id', we can avoid this issue\n\t            var id = tAttr.uid || service.getUniqueFieldId(),\n\t                name = tAttr.name || id,\n\t                // Doing this *will* break radio buttons, but they SHOULD provide a name anyway (for their own good)\n\t            inputElem = tElement.find(params.inputElementName || 'input'),\n\t                labelElem = tElement.find('label'),\n\t                required = service.getRequiredAttribute(tAttr.required);\n\t\n\t            service.decorateLabel(labelElem, required, id, tAttr.labelClass, tAttr.hideLabel, tAttr.hideRequiredIndicator, tAttr.labelSuffix);\n\t            inputElem = service.decorateInputField(inputElem, tElement, tAttr, id, name, required);\n\t\n\t            // Do component-specific config last\n\t            params.configFn(tElement, tAttr, id, name, inputElem, labelElem);\n\t\n\t            // Clean up special attributes (to make HTML look nicer)\n\t            tElement.removeAttr('uid').removeAttr('name').removeAttr('label').removeAttr('required').removeAttr('field-hint').removeAttr('input-type').removeAttr('hide-label').removeAttr('hideRequiredIndicator').removeAttr('label-class').removeAttr('field-errors').removeAttr('text-errors');\n\t          },\n\t          templateUrl: function templateUrl(element, attr) {\n\t            // Check the element for a \"template\" attribute, which allows customisation-per-control. Otherwise, use the control-wide template.\n\t            return attr.template || service.getHTMLTemplate(element, params.controlName);\n\t          }\n\t        };\n\t\n\t        return directive;\n\t      },\n\t\n\t      getUniqueFieldId: function getUniqueFieldId() {\n\t        return '' + self.defaults.idPrefix + counter++;\n\t      },\n\t\n\t      getHTMLTemplate: function getHTMLTemplate(element, type) {\n\t        // Allow different templates to be applied for different form-styles (eg for horizontal forms, inline forms, \"normal\" forms).\n\t        // This is an advanced feature that most users will not need.\n\t        // E.g.: self.defaults.templates['select']['form-inline'] = 'path/to/your/custom/template.html'\n\t\n\t        // Check this element's parent-form-element-classes to see if they match. First match, wins.\n\t        var parentFormClasses = (element.inheritedData('formElementClasses') || '').split(' ');\n\t        var result = self.defaults.templates[type].template; // The default template, if nothing else is specified.\n\t\n\t        for (var i = 0; i < parentFormClasses.length; i++) {\n\t          var template = self.defaults.templates[type][parentFormClasses[i]];\n\t          if (template) {\n\t            result = template;\n\t            break;\n\t          }\n\t        }\n\t\n\t        return result;\n\t      },\n\t\n\t      addToAttribute: function addToAttribute(element, attributeName, value) {\n\t        var existingVal = element.attr(attributeName);\n\t        element.attr(attributeName, (existingVal ? existingVal + ' ' : '') + value);\n\t      },\n\t\n\t      removeFromAttribute: function removeFromAttribute(element, attributeName, value) {\n\t        // Borrowed this statement from Angular.js\n\t        var newValue = StringUtil.trim((' ' + (element.attr(attributeName) || '') + ' ').replace(/[\\n\\t]/g, ' ').replace(' ' + StringUtil.trim(value) + ' ', ' '));\n\t\n\t        // Remove the attribute if it is empty\n\t        if (newValue === '') {\n\t          element.removeAttr(attributeName);\n\t        } else {\n\t          element.attr(attributeName, newValue);\n\t        }\n\t      },\n\t\n\t      getRequiredAttribute: function getRequiredAttribute(required) {\n\t        // When we set required=\"true\" on a parent directive (like on-off-button), inputElem.attr('required', 'true')\n\t        // becomes <input required=\"required\" due to browser interference. So detect this case, and replace it with \"true\"\n\t        // In v1.3, required=\"true\" becomes required=\"\".\n\t        if (required === 'required' || required === '' || required === 'true') {\n\t          return 'true';\n\t        } else if (required === undefined) {\n\t          return 'false';\n\t        }\n\t        return required;\n\t      },\n\t\n\t      decorateLabel: function decorateLabel(labelElem, required, id, labelClass, hideLabelExpr, hideRequiredIndicator, labelSuffix) {\n\t        if (id) {\n\t          labelElem.attr('for', id);\n\t        }\n\t        if (labelClass) {\n\t          labelElem.addClass(labelClass);\n\t        }\n\t        if (hideLabelExpr) {\n\t          labelElem.attr('ng-class', '{\\'sr-only\\': ' + hideLabelExpr + '}');\n\t        }\n\t        if (!hideRequiredIndicator) {\n\t          labelElem.append('<span required-marker hide=\"!(' + required + ')\"></span>');\n\t        }\n\t        // Some labels have suffix text - text that helps with describing the label, but isn't really the label text.\n\t        // E.g. Amount ($AUD)\n\t        if (labelSuffix) {\n\t          labelElem.text(labelElem.text() + ' ' + labelSuffix);\n\t        }\n\t      },\n\t\n\t      decorateInputField: function decorateInputField(inputElem, hostElement, attr, id, name, required) {\n\t        if (attr.inputType) {\n\t          // inputElem.attr('type', attr.inputType); // THIS WILL NOT WORK ON IE8!\n\t          // Instead, we must replace the entire node with the only property which SHOULD exist on the template: 'class'\n\t          inputElem.replaceWith('<input type=\"' + attr.inputType + '\" class=\"' + inputElem.attr('class') + '\">');\n\t          inputElem = hostElement.find('input');\n\t        }\n\t\n\t        inputElem.attr('id', id);\n\t\n\t        // Allow the name to be interpolated\n\t        inputElem.attr('name', name);\n\t\n\t        // Apply all of the ff-* attributes to the input element. Use the original attribute names\n\t        // attr.$attr contains the snake-case names e.g. 'form-field' vs camel case 'formField'\n\t        for (var a in attr.$attr) {\n\t          if (a.indexOf('ff') === 0) {\n\t            // Don't search for 'ff-' as the '-' has been replaced with camel case now\n\t            var origAttrName = attr.$attr[a].substr(3);\n\t\n\t            if (origAttrName === 'class') {\n\t              inputElem.addClass(attr[a]);\n\t\n\t              // Special case for type property. It *must* be read-only. Therefore, don't write it to the element\n\t              // See http://stackoverflow.com/questions/8378563/why-cant-i-change-the-type-of-an-input-element-to-submit\n\t            } else if (origAttrName !== 'type') {\n\t                inputElem.attr(origAttrName, attr[a]);\n\t              }\n\t\n\t            // Remove all attributes off the host element\n\t            hostElement.removeAttr(attr.$attr[a]);\n\t          }\n\t        }\n\t\n\t        inputElem.attr('ng-required', required);\n\t        inputElem.attr('aria-required', '{{!!(' + required + ')}}'); // evaluates to true / false\n\t        return inputElem;\n\t      },\n\t\n\t      createErrorFeatures: function createErrorFeatures(parentElement, inputElement, name, fieldLabel, fieldErrors, textErrors) {\n\t        if (fieldErrors || textErrors) {\n\t          // Add an fieldErrorControllers attribute to the element, to hook-up the error features\n\t          inputElement.attr('field-error-controller', '');\n\t\n\t          var fieldLabelStr = fieldLabel ? ' field-label=\"' + fieldLabel + '\"' : '';\n\t          var errorContainerElem = _angular2.default.element('<div error-container field-name=\"' + name + '\"' + fieldLabelStr + '></div>');\n\t          if (fieldErrors) {\n\t            errorContainerElem.attr('field-errors', fieldErrors);\n\t          }\n\t          if (textErrors) {\n\t            errorContainerElem.attr('text-errors', textErrors);\n\t          }\n\t          parentElement.append(errorContainerElem);\n\t        }\n\t      },\n\t\n\t      createFieldHint: function createFieldHint(hostElement, inputElement, fieldHint, fieldHintId, fieldHintDisplay) {\n\t        var hintElement;\n\t\n\t        if (fieldHint) {\n\t          // If we have a field hint, add that as well\n\t          if (fieldHintDisplay) {\n\t            // If a field hint display rule exists, implement.\n\t            hintElement = _angular2.default.element('<p ng-if=\"' + fieldHintDisplay + '\" class=\"help-block\" id=\"' + fieldHintId + '\">' + fieldHint + '</p>');\n\t          } else {\n\t            hintElement = _angular2.default.element('<p class=\"help-block\" id=\"' + fieldHintId + '\">' + fieldHint + '</p>');\n\t          }\n\t          hostElement.append(hintElement);\n\t          inputElement.attr('aria-describedby', fieldHintId);\n\t        }\n\t      },\n\t\n\t      buildNgClassExpression: function buildNgClassExpression(inputElem, targetElem) {\n\t        // If the inputElem has an ngModel and/or ngChecked attribute, create the ng-class attribute\n\t        //todo.. test checkbox implementation\n\t        var modelStr = inputElem.attr('ng-model'),\n\t            checkedStr = inputElem.attr('ng-checked'),\n\t            disabledStr = inputElem.attr('ng-disabled'),\n\t            value = inputElem.attr('value'),\n\t            // a string - used for Radio buttons\n\t        ngValue = inputElem.attr('ng-value'),\n\t            // an expression - used for Radio buttons\n\t        ngTrueValue = inputElem.attr('ng-true-value');\n\t\n\t        if (modelStr) {\n\t          if (ngValue || ngTrueValue) {\n\t            modelStr += ' === ' + (ngValue || ngTrueValue);\n\t          } else if (value) {\n\t            // The value is ALWAYS a string\n\t            modelStr += ' === \\'' + value + '\\'';\n\t          } else {\n\t            modelStr += ' === true'; // For checkboxes, in the absence of ng-true-value\n\t          }\n\t        }\n\t\n\t        if (modelStr && checkedStr) {\n\t          modelStr += ' || ' + checkedStr;\n\t        } else if (checkedStr) {\n\t          modelStr = checkedStr;\n\t        }\n\t\n\t        if (modelStr && disabledStr) {\n\t          targetElem.attr('ng-class', '{\\'checked\\': ' + modelStr + ', \\'disabled\\': ' + disabledStr + '}');\n\t        } else if (modelStr) {\n\t          targetElem.attr('ng-class', '{\\'checked\\': ' + modelStr + '}');\n\t        }\n\t      },\n\t\n\t      validateComponentStructure: function validateComponentStructure(componentName, element, requiredElements, attr, requiredAttributes) {\n\t        for (var i = 0; i < requiredElements.length; i++) {\n\t          if (!element.find(requiredElements[i])) {\n\t            throw new Error('The ' + componentName + ' component template requires a ' + requiredElements[i] + ' element.');\n\t          }\n\t        }\n\t\n\t        for (var j = 0; j < requiredAttributes.length; j++) {\n\t          if (!attr[requiredAttributes[j]]) {\n\t            throw new Error('The ' + componentName + ' component requires a ' + requiredAttributes[j] + ' attribute.');\n\t          }\n\t        }\n\t      }\n\t\n\t    };\n\t    return service;\n\t  }];\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */,\n/* 6 */,\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.common.utility', []);\n\t\n\texports.default = mod.name;\n\t\n\t\n\tmod.constant('ngFormLibDateUtil', {\n\t  convertDate: function convertDate(dateStr, newSep) {\n\t    // Converts a date between dd/mm/yyyy and yyyy-mm-dd\n\t    if (!dateStr || !newSep || !(newSep === '/' || newSep === '-')) {\n\t      return dateStr;\n\t    }\n\t\n\t    // Choose a separator string that is the 'opposite' of the desired separator\n\t    var oldSep = newSep === '/' ? '-' : '/',\n\t        parts = dateStr.split(oldSep);\n\t\n\t    // if we get a dodgy date OR you tried to convert a date that was already in the correct format, return the input\n\t    if (isNaN(parts.join('')) || parts.length !== 3) {\n\t      return dateStr;\n\t    }\n\t\n\t    // Swap the year and day parts around\n\t    return parts[2] + newSep + parts[1] + newSep + parts[0];\n\t  },\n\t  formatDay: function formatDay(dayOrDate, month, year) {\n\t    var dd = dayOrDate,\n\t        mm = month,\n\t        yyyy = year;\n\t    if (dayOrDate.getUTCDay) {\n\t      dd = dayOrDate.getDate();\n\t      mm = dayOrDate.getMonth() + 1; //January is 0!`\n\t      yyyy = dayOrDate.getFullYear();\n\t    }\n\t    return (dd < 10 ? '0' + dd : dd) + '/' + (mm < 10 ? '0' + mm : mm) + '/' + yyyy;\n\t  },\n\t  dateAdd: function dateAdd(dateStr, numDays) {\n\t    // Return a modified date in ISO format\n\t    var myDate = this.getDate(dateStr);\n\t    myDate.setDate(myDate.getDate() + numDays);\n\t\n\t    return this.formatDay(myDate);\n\t  },\n\t  getToday: function getToday(optionalDate) {\n\t    return this.formatDay(optionalDate || new Date());\n\t  },\n\t  isISODate: function isISODate(dateStr) {\n\t    return typeof dateStr === 'string' && dateStr.indexOf('-') > 0;\n\t  },\n\t  getDate: function getDate(dateStr) {\n\t    if (!this.isISODate(dateStr)) {\n\t      dateStr = this.convertDate(dateStr, '-');\n\t    }\n\t    return new Date(dateStr);\n\t  },\n\t  monthsBetween: function monthsBetween(date1, date2) {\n\t    return date2.getMonth() - date1.getMonth() + 12 * (date2.getFullYear() - date1.getFullYear());\n\t  }\n\t});\n\t\n\tmod.constant('ngFormLibStringUtil', function () {\n\t  var trimRegExp = /^\\s+|\\s+$/g;\n\t\n\t  return {\n\t    trim: function trim(text) {\n\t      if (typeof text === 'string') {\n\t        return text.replace(trimRegExp, '');\n\t      }\n\t      return text;\n\t    }\n\t  };\n\t}());\n\t\n\tmod.constant('ngFormLibNumberUtil', function () {\n\t  var isDigitsRegExp = /^\\d+$/;\n\t\n\t  return {\n\t    isDigits: function isDigits(text) {\n\t      return isDigitsRegExp.test(text);\n\t    }\n\t  };\n\t}());\n\t\n\tmod.constant('ngFormLibObjectUtil', {\n\t  getUniqueId: function getUniqueId() {\n\t    return ('' + new Date().getTime() + Math.random()).replace(/\\./, '');\n\t  },\n\t  toArray: function toArray(obj) {\n\t    var arr = [];\n\t    for (var i in obj) {\n\t      if (obj.hasOwnProperty(i)) {\n\t        arr[arr.length] = { key: i, value: obj[i] };\n\t      }\n\t    }\n\t    arr.sort(function compare(a, b) {\n\t      return a.key < b.key;\n\t    });\n\t    return arr;\n\t  }\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _FormControlService = __webpack_require__(4);\n\t\n\tvar _FormControlService2 = _interopRequireDefault(_FormControlService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.common.fieldErrorController', [_FormControlService2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t/**\n\t * The Field Error Controller directive is designed to indicate to the browser when the field is in error\n\t *  and what the errors are. It applies the form-policy for showing errors\n\t *\n\t * It works in tandem with the form controller (and FormPolicy.js) to identify when a form-element has an error, and decorates\n\t *  the element accordingly.\n\t *\n\t * It also toggles the fieldController.fieldState flag, based on the form policy provided\n\t *\n\t */\n\t\n\t// INPUT:\n\t//  <input ... field-error-controller></input>\n\t\n\t// OUTPUT:\n\t//  <input ... aria-invalid=\"false/true\" aria-describedby=\"fieldId-errors\">\n\t\n\tmod.directive('fieldErrorController', ['formControlService', '$timeout', function (formControlService, $timeout) {\n\t\n\t  function updateAriaFeatures(fieldState, element, formName, fieldName) {\n\t    element.attr('aria-invalid', fieldState === 'error');\n\t    var errorElemId = formName + '-' + fieldName + '-errors-aria';\n\t\n\t    if (fieldState === 'error') {\n\t      // Use the errorContainer's special ARIA element as the source of the error text\n\t      formControlService.addToAttribute(element, 'aria-describedby', errorElemId);\n\t    } else {\n\t      formControlService.removeFromAttribute(element, 'aria-describedby', errorElemId);\n\t    }\n\t  }\n\t\n\t  function updateElementStyle(fieldState, element, formPolicy) {\n\t    element[fieldState === 'error' ? 'addClass' : 'removeClass'](formPolicy.fieldErrorClass);\n\t    element[fieldState === 'success' ? 'addClass' : 'removeClass'](formPolicy.fieldSuccessClass);\n\t  }\n\t\n\t  function setupCanShowErrorPropertyOnNgModelController(scope, formController, ngModelController, element, name) {\n\t    // Using the form policy, determine when to show errors for this field\n\t    var formPolicy = formController._policy,\n\t        formName = formController.$name,\n\t        fieldName = formName + '.' + name,\n\t        stateConditions = formPolicy.stateDefinitions(formName, fieldName);\n\t\n\t    formPolicy.checkForStateChanges(formController._scope, element, name, stateConditions, ngModelController, formController);\n\t  }\n\t\n\t  return {\n\t    restrict: 'AE',\n\t    require: ['?ngModel', '?^form', '?^formGroup'], // Require the formController controller somewhere in the parent hierarchy\n\t    replace: true,\n\t    link: function link(scope, element, attr, controllers) {\n\t      // Tried to use a template string, but the model was not binding properly. Using $compile() works :)\n\t      var ngModelController = controllers[0],\n\t          formController = controllers[1],\n\t          formGroupElement = (controllers[2] || {}).$element || element,\n\t          // This looks for a parent directive called formGroup, which has a controller, which has an $element property\n\t      name = attr.name;\n\t\n\t      if (formController) {\n\t        var formName = formController.$name,\n\t            errorBehaviour = formController._applyFormBehaviourOnStateChangePolicy; // returns a function which encapsulates the form policy rules for the behaviour to apply when errors show\n\t\n\t        if (ngModelController) {\n\t          setupCanShowErrorPropertyOnNgModelController(scope, formController, ngModelController, element, name);\n\t        }\n\t\n\t        // When the error-showing flag changes, update the field style\n\t        formController._scope.$watch(formName + '.' + name + '.fieldState', function (fieldState) {\n\t          updateAriaFeatures(fieldState, element, formName, name);\n\t          updateElementStyle(fieldState, formGroupElement, formController._policy);\n\t\n\t          // Apply the error behaviour behaviour\n\t          errorBehaviour.applyBehaviour(element, fieldState, false);\n\t        });\n\t\n\t        // Listen to form-submit events, to determine what to focus on too\n\t        scope.$on('event:FormSubmitAttempted', function () {\n\t          // Make sure that the field-level watchers have a chance to fire first, so use a timeout\n\t          $timeout(function () {\n\t            errorBehaviour.applyBehaviour(element, ngModelController.fieldState, true);\n\t          }, 1);\n\t        });\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\t// This directive\n\tmod.directive('formGroup', [function () {\n\t  return {\n\t    restrict: 'AC',\n\t    controller: ['$scope', '$element', function ($scope, $element) {\n\t      this.$element = $element;\n\t    }]\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _index = __webpack_require__(3);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formCheckbox', [_index2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//  <form-checkbox id=\"id\" name=\"name\" required=\"{{expression}}\"\n\t//      ff-class=\"span12\" ff-ng-model=\"application.contentType\" ff-value=\"software\" ff-aria-label=\"Software\"\n\t//        ff-ng-click=\"doSomething()\"\n\t//      field-errors=\"{required: 'Please select'}\"\n\t//      text-errors=\"['wrong value']\"\n\t//      >My label with <a href=\"http://www.google.com/\">HTML bits</a> in it</form-checkbox>\n\t\n\t// OUTPUT:\n\t\n\tmod.directive('formCheckbox', ['formControlService', function (formControlService) {\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formCheckbox',\n\t    expectedTemplateElements: ['input', 'label', 'div'],\n\t    expectedAttributes: [],\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem) {\n\t      // Move the class attribute from the outer-DIV to the checkbox DIV (special case)\n\t      var checkboxDiv = tElement.find('div');\n\t      checkboxDiv.addClass(tElement.attr('class'));\n\t      tElement.removeAttr('class');\n\t\n\t      formControlService.createErrorFeatures(tElement, inputElem, name, '', tAttr.fieldErrors, tAttr.textErrors);\n\t      formControlService.buildNgClassExpression(inputElem, inputElem); // Put the ng-class onto the input element itself, as this makes styling easier\n\t    }\n\t  });\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _common = __webpack_require__(3);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formDate', [_common2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//    <div form-date id=\"toDate\" name=\"toDate\" label=\"To date\" hide-label=\"true\" input-type=\"text\"\n\t//    ff-ng-model=\"acctCtrl.search.toDate\" ff-max-date=\"today\" ff-bs-show=\"acctCtrl.datePickers.datePickerTo\"\n\t//    ff-ng-blur=\"acctCtrl.toggleDatePicker('datePickerTo', true)\"\n\t//    ff-ng-focus=\"acctCtrl.toggleDatePicker('datePickerFrom', true)\"\n\t//    ff-class=\"form-control input-beta input-date\"\n\t//    field-errors=\"{date: 'ERROR.DATE_INVALID'}\" >\n\t//      <i class=\"calendar\" ng-click=\"acctCtrl.toggleDatePicker('datePickerTo')\"></i>\n\t//    </div>\n\t\n\tmod.directive('formDate', ['formControlService', function (formControlService) {\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formDate',\n\t    expectedTemplateElements: ['input', 'label'],\n\t    expectedAttributes: ['label'],\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem, labelElem) {\n\t      labelElem.prepend(tAttr.label);\n\t\n\t      //formControlService.decorateInputGroup(tElement.find('div'), tAttr.inputGroupClass);\n\t      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n\t      formControlService.createErrorFeatures(inputElem.parent(), inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n\t    }\n\t  });\n\t}]);\n\t\n\tmod.directive('formDateFormat', ['ngFormLibDateUtil', function (DateUtil) {\n\t  // All dates greater than AD 0 and less than AD 10000 in dd/mm/yyyy format\n\t  // RegEx behaves oddly if /g is uses in Regexp.test() situations\n\t  var dateRegEx = /^(((0[1-9]|[12][0-9]|3[01])([\\/])(0[13578]|10|12)([\\/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([\\/])(0[469]|11)([\\/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([\\/])(02)([\\/])(\\d{4}))|((29)(\\/)(02)([\\/])([02468][048]00))|((29)([\\/])(02)([\\/])([13579][26]00))|((29)([\\/])(02)([\\/])([0-9][0-9][0][48]))|((29)([\\/])(02)([\\/])([0-9][0-9][2468][048]))|((29)([\\/])(02)([\\/])([0-9][0-9][13579][26])))$/;\n\t\n\t  return {\n\t    require: 'ngModel',\n\t    priority: 150, // Higher priority than ui-mask (100), so the postLink function runs last\n\t    link: function link(scope, elem, attrs, ctrl) {\n\t\n\t      ctrl.$parsers.unshift(function (viewValue) {\n\t\n\t        // If viewValue is undefined or null, jump out\n\t        if (!viewValue) {\n\t          ctrl.$setValidity('date', true);\n\t          ctrl.$setValidity('minDate', true); // Turn off the error if the date format isn't valid\n\t          ctrl.$setValidity('maxDate', true); // Turn off the error if the date format isn't valid\n\t          return viewValue;\n\t        }\n\t\n\t        // If viewValue is a string of 8 digits, then convert it to dd/dd/dddd first\n\t        if (viewValue.length === 8 && !isNaN(viewValue * 1)) {\n\t          viewValue = viewValue.substr(0, 2) + '/' + viewValue.substr(2, 2) + '/' + viewValue.substr(4);\n\t        }\n\t\n\t        // Check that it is a valid date\n\t        var dateFormatValid = dateRegEx.test(viewValue) || typeof viewValue === 'undefined' || !viewValue;\n\t        ctrl.$setValidity('date', dateFormatValid);\n\t\n\t        //console.log('dateInput: ' + viewValue + ', ' + ctrl.$modelValue);\n\t\n\t        // If the date is valid\n\t        if (dateFormatValid && viewValue) {\n\t          var fieldDate = DateUtil.getDate(viewValue);\n\t          // and there is a min date, check if the value is greater than the min date\n\t          if (attrs.minDate) {\n\t            var minDate = DateUtil.getDate(attrs.minDate);\n\t            ctrl.$setValidity('minDate', fieldDate.getTime() >= minDate.getTime());\n\t          } else {\n\t            ctrl.$setValidity('minDate', true);\n\t          }\n\t          // and there is a max date, check if the value is less than the max date\n\t          if (attrs.maxDate) {\n\t            var maxDate;\n\t\n\t            if (attrs.maxDate === 'today') {\n\t              maxDate = DateUtil.getDate(DateUtil.getToday());\n\t            } else {\n\t              maxDate = DateUtil.getDate(attrs.maxDate);\n\t            }\n\t\n\t            ctrl.$setValidity('maxDate', fieldDate.getTime() <= maxDate.getTime());\n\t          } else {\n\t            ctrl.$setValidity('maxDate', true);\n\t          }\n\t        } else {\n\t          ctrl.$setValidity('minDate', true); // Turn off the error if the date format isn't valid\n\t          ctrl.$setValidity('maxDate', true); // Turn off the error if the date format isn't valid\n\t        }\n\t        return viewValue;\n\t      });\n\t\n\t      ctrl.$viewChangeListeners.push(function () {\n\t        // If there is a date-change attribute, execute it when the control is valid\n\t        if (attrs.dateChange && ctrl.$valid) {\n\t          scope.$eval(attrs.dateChange);\n\t        }\n\t      });\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _common = __webpack_require__(3);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formInput', [_common2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//  <form-input id=\"\" name=\"\" label=\"Last name\" required=\"{{expression}}\"\n\t//      ff-class=\"span12\" input-type=\"text|tel|email\" ff-ng-model=\"application.lastName\"\n\t//      ff-maxlength=\"40\" ff-ng-pattern=\"/^[a-zA-Z0-9 \\-.']+$/\"\n\t//      field-hint=\"This must be the last name of the person who originally applied for the service.\"\n\t//      field-errors=\"{required: 'Please enter a valid last name', pattern: 'Please enter a valid last name'}\"\n\t//      text-errors=\"['data.errors.']\"\n\t//      content-class=\"span3\"\n\t//      >My content</form-input>\n\t\n\t// OUTPUT:\n\t\n\tmod.directive('formInput', ['formControlService', function (formControlService) {\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formInput',\n\t    expectedTemplateElements: ['input', 'label'],\n\t    expectedAttributes: ['label', 'inputType'],\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem, labelElem) {\n\t      labelElem.prepend(tAttr.label);\n\t      addPlaceholder(inputElem, tAttr.placeholder); // Do this to be API-compatible with the form-select control. ff-placeholder is still supported. Use one or the other.\n\t\n\t      // If the user wants to use 'input-addon-prefix' or 'input-addon-suffix', change the DOM\n\t      var hasInputGroup = addInputGroup(inputElem, tAttr.inputPrefix, tAttr.inputSuffix);\n\t      var parentElemForErrors = hasInputGroup ? inputElem.parent().parent() : inputElem.parent();\n\t\n\t      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n\t      formControlService.createErrorFeatures(parentElemForErrors, inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n\t    }\n\t  });\n\t}]);\n\t\n\tfunction addPlaceholder(inputElem, placeholderText) {\n\t  if (placeholderText) {\n\t    inputElem.attr('placeholder', placeholderText);\n\t  }\n\t}\n\t\n\tfunction addInputGroup(inputElem, inputGroupPrefix, inputGroupSuffix) {\n\t  if (inputGroupPrefix || inputGroupSuffix) {\n\t    inputElem.wrap('<div class=\"input-group\">'); //inputElem.parent(); // This should be the 'control-row' element//wrap('<div class=\"input-group\">');\n\t    var wrapper = inputElem.parent();\n\t\n\t    if (inputGroupPrefix) {\n\t      wrapper.prepend('<span class=\"input-group-addon\">' + inputGroupPrefix + '</span>');\n\t    }\n\t    if (inputGroupSuffix) {\n\t      wrapper.append('<span class=\"input-group-addon\">' + inputGroupSuffix + '</span>');\n\t    }\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _common = __webpack_require__(3);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formRadioButton', [_common2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//  <form-radio-button uid=\"fld\" name=\"name\" aria-label=\"Book Type\" label-class=\"btn btn-toggle\"\n\t//    ff-class=\"someCSS\" ff-ng-model=\"application.bookType\" ff-value=\"Fiction\" ng-click=\"loadFiction()\" class=\"span6\">\n\t//     <icon class=\"icon-fiction\"></icon>Fiction\n\t//  </form-radio-button>\n\t\n\t// OUTPUT:\n\t\n\tmod.directive('formRadioButton', ['formControlService', function (formControlService) {\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formRadioButton',\n\t    expectedTemplateElements: ['input', 'label', 'div'],\n\t    expectedAttributes: [], // The template should NOT have a form-group element inside it, as this has to be specified externally (due to the group-nature of radio buttons)\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem) {\n\t      // Move the class attribute from the outer-DIV to the radio-button DIV (special case)\n\t      var rbDiv = tElement.find('div');\n\t      rbDiv.addClass(tElement.attr('class'));\n\t      tElement.removeAttr('class');\n\t\n\t      formControlService.createErrorFeatures(tElement, inputElem, name, '', tAttr.fieldErrors, tAttr.textErrors);\n\t      formControlService.buildNgClassExpression(inputElem, inputElem); // Put the ng-class onto the input element itself, as this makes styling easier\n\t    }\n\t  });\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formReset', []);\n\t\n\texports.default = mod.name;\n\t\n\t\n\tmod.directive('formReset', ['$parse', function ($parse) {\n\t\n\t  function resetFieldState(controlMap) {\n\t    // Loops through the controlMap and reset's each field's state\n\t    for (var item in controlMap) {\n\t      if (controlMap.hasOwnProperty(item)) {\n\t        var controlList = controlMap[item];\n\t        for (var j = 0, jLen = controlList.length; j < jLen; j++) {\n\t          var control = controlList[j].controller;\n\t          control.fieldState = '';\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return {\n\t    restrict: 'A',\n\t    require: '^form',\n\t    link: function link(scope, element, attr, controller) {\n\t      var ngModelGet = $parse(attr.formReset),\n\t          ngModelSet = ngModelGet.assign;\n\t\n\t      if (!ngModelSet) {\n\t        throw Error('formReset requires an assignable scope-expression. \"' + attr.formReset + '\" is un-assignable.');\n\t      }\n\t\n\t      // Get a copy of the data as soon as the directive is created, which is after the scope/controller has been initialised (safe)\n\t      var originalData = _angular2.default.copy(ngModelGet(scope));\n\t\n\t      element.on('click', function () {\n\t        if (typeof controller.setSubmitted === 'function') {\n\t          controller.setSubmitted(false);\n\t        }\n\t        // Use a *copy* of the original data, as we don't want originalData to be modified by subsequent changes to the model by the form controls\n\t        ngModelSet(scope, _angular2.default.copy(originalData));\n\t        resetFieldState(controller._controls || {});\n\t        controller.$setPristine();\n\t\n\t        scope.$emit('event:FormReset');\n\t        scope.$digest();\n\t      });\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _common = __webpack_require__(3);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formSelect', [_common2.default, _ErrorMessageContainer2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// INPUT:\n\t//  <form-select id=\"frm-size\" name=\"bookSize\" required=\"true\" label=\"Approximate size\"\n\t//    ff-class=\"span12\" ff-ng-model=\"model.size\" placeholder=\"Select a size bracket\"\n\t//    ff-ng-options=\"option.value as option.name for option in refData.bookSizes\"\n\t//    field-errors=\"{required: 'Please select a size bracket'}\"\n\t//    text-errors=\"['data.errors']\"></form-select>\n\t\n\t// OUTPUT:\n\t\n\tmod.directive('formSelect', ['formControlService', function (formControlService) {\n\t\n\t  function addPlaceholder(selectElem, placeholderText) {\n\t    if (placeholderText) {\n\t      selectElem.append('<option translate value=\"\">' + placeholderText + '</option>');\n\t    }\n\t  }\n\t\n\t  return formControlService.buildDirective({\n\t    controlName: 'formSelect',\n\t    inputElementName: 'select',\n\t    expectedTemplateElements: ['select', 'label'],\n\t    expectedAttributes: ['label'],\n\t    configFn: function configFn(tElement, tAttr, id, name, inputElem, labelElem) {\n\t      labelElem.prepend(tAttr.label);\n\t      addPlaceholder(inputElem, tAttr.placeholder); // Adds the extra option element to the start of the <option>\n\t\n\t      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n\t      formControlService.createErrorFeatures(inputElem.parent(), inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n\t    }\n\t  });\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.formSubmit', []);\n\t\n\texports.default = mod.name;\n\t\n\t/**\n\t *  formSubmit - Executes an expression when the form is valid (essentially a form.submit() handler).\n\t *\n\t *  It can be applied to either the form element or to a button.\n\t *\n\t */\n\t\n\tmod.directive('formSubmit', ['$parse', function ($parse) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['^form'], // Get the form controller\n\t    link: function link(scope, element, attr, controller) {\n\t\n\t      var fn = $parse(attr.formSubmit) || _angular2.default.noop,\n\t          isForm = element[0].tagName === 'FORM',\n\t          formController = controller[0];\n\t\n\t      element.bind(isForm ? 'submit' : 'click', function (event) {\n\t\n\t        formController.setSubmitted(true);\n\t\n\t        scope.$apply(function () {\n\t          //scope.$emit('event:FormSubmitAttempted');\n\t\n\t          if (formController.$valid) {\n\t            if (fn(scope, { $event: event }) !== false) {\n\t              // Needed by the tracking tool as it clears the input data after a submission.\n\t              // Potentially, form field validation to be done here, but unnecessary at the moment.\n\t              // The reset behaviour can be over-ridden by returning false from the called function(maybe prevent default aswell?)\n\t              formController.setSubmitted(false);\n\t              formController.$setPristine();\n\t            }\n\t          } else {\n\t            event.preventDefault();\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _ErrorMessageContainer = __webpack_require__(2);\n\t\n\tvar _ErrorMessageContainer2 = _interopRequireDefault(_ErrorMessageContainer);\n\t\n\tvar _FormCheckbox = __webpack_require__(9);\n\t\n\tvar _FormCheckbox2 = _interopRequireDefault(_FormCheckbox);\n\t\n\tvar _FormDate = __webpack_require__(10);\n\t\n\tvar _FormDate2 = _interopRequireDefault(_FormDate);\n\t\n\tvar _FormInput = __webpack_require__(11);\n\t\n\tvar _FormInput2 = _interopRequireDefault(_FormInput);\n\t\n\tvar _FormRadioButton = __webpack_require__(12);\n\t\n\tvar _FormRadioButton2 = _interopRequireDefault(_FormRadioButton);\n\t\n\tvar _FormReset = __webpack_require__(13);\n\t\n\tvar _FormReset2 = _interopRequireDefault(_FormReset);\n\t\n\tvar _FormSelect = __webpack_require__(14);\n\t\n\tvar _FormSelect2 = _interopRequireDefault(_FormSelect);\n\t\n\tvar _FormSubmit = __webpack_require__(15);\n\t\n\tvar _FormSubmit2 = _interopRequireDefault(_FormSubmit);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// We need the utility module for the ngFormLibDateUtil.getDate() method for the formDateFormat directive, and ngFormLibStringUtil.trim() in controls.common\n\tvar mod = _angular2.default.module('ngFormLib.controls', [_ErrorMessageContainer2.default, _FormCheckbox2.default, _FormDate2.default, _FormInput2.default, _FormRadioButton2.default, _FormReset2.default, _FormSelect2.default, _FormSubmit2.default]);\n\t\n\texports.default = mod.name;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _FormControlService = __webpack_require__(4);\n\t\n\tvar _FormControlService2 = _interopRequireDefault(_FormControlService);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib.controls.requiredMarker', [_FormControlService2.default]);\n\t\n\texports.default = mod.name;\n\t\n\t// Add a simple \"required\" marker that is not read-out by screen readers (as the field should also have a required indicator)\n\t//\n\t// INPUT:\n\t//  <span required-marker></span>\n\t//  <span required-marker hide=\"isNotRequired\">Some Text</span>\n\t\n\t// OUTPUT:\n\t//  <span class=\"required\" aria-hidden=\"true\" ng-class=\"{\\'ng-hide\\': hide}\" ng-transclude=\"\"></span>\n\t//  <span class=\"required\" aria-hidden=\"true\" ng-class=\"{\\'ng-hide\\': hide}\" ng-transclude=\"\" hide=\"isNotRequired\">Some Text</span>\n\t\n\tmod.directive('requiredMarker', ['formControlService', function (formControlService) {\n\t\n\t  return {\n\t    restrict: 'AE',\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function templateUrl(element, attr) {\n\t      return attr.template || formControlService.getHTMLTemplate(element, 'requiredMarker');\n\t    },\n\t    scope: {\n\t      hide: '='\n\t    }\n\t  };\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar _angularAnimate = __webpack_require__(6);\n\t\n\tvar _angularAnimate2 = _interopRequireDefault(_angularAnimate);\n\t\n\tvar _FormPolicy = __webpack_require__(19);\n\t\n\tvar _FormPolicy2 = _interopRequireDefault(_FormPolicy);\n\t\n\tvar _controls = __webpack_require__(16);\n\t\n\tvar _controls2 = _interopRequireDefault(_controls);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar mod = _angular2.default.module('ngFormLib', [_angularAnimate2.default, _FormPolicy2.default,\n\t//    Add the policies you want, or define your own:\n\t//    'ngFormLib.policy.checkForStateChanges',\n\t//    'ngFormLib.policy.displayError',\n\t//    'ngFormLib.policy.focusBehaviour',\n\t_controls2.default]);\n\t\n\texports.default = mod.name;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// The form policy intentionally has no hard dependencies.\n\t// If there are form-policy values that exist when the service is being constructed, it will use them.\n\t// Otherwise it will use no-op policy functions.\n\tvar mod = _angular2.default.module('ngFormLib.policy', []);\n\t\n\texports.default = mod.name;\n\t\n\t// This is a configurable service\n\t// It should contain the _default_ values for form policies\n\t\n\tmod.provider('formPolicyService', function () {\n\t  var self = this,\n\t      noop = _angular2.default.noop,\n\t      nullBehaviourOnStateChange = function nullBehaviourOnStateChange() {\n\t    return {\n\t      applyBehaviour: noop,\n\t      resetBehaviour: noop\n\t    };\n\t  },\n\t      nullStateChanges = function nullStateChanges() {\n\t    return {};\n\t  };\n\t\n\t  self.defaults = {\n\t    formSubmitAttemptedClass: 'form-submit-attempted',\n\t    fieldErrorClass: 'has-error',\n\t    fieldSuccessClass: 'has-success',\n\t    behaviourOnStateChange: null, // Previously called focusBehavior\n\t    checkForStateChanges: null,\n\t    stateDefinitions: null,\n\t    fieldFocusScrollOffset: 0\n\t  };\n\t\n\t  this.$get = ['$injector', function ($injector) {\n\t\n\t    function getService(name) {\n\t      try {\n\t        return $injector.get(name);\n\t      } catch (e) {\n\t        return null; // Provider-not-found error, ignore and move on\n\t      }\n\t    }\n\t\n\t    // Policy precedence: this.defaults, policy-value-object, noop\n\t    self.defaults.behaviourOnStateChange = self.defaults.behaviourOnStateChange || getService('formPolicyBehaviourOnStateChange') || nullBehaviourOnStateChange;\n\t    self.defaults.checkForStateChanges = self.defaults.checkForStateChanges || getService('formPolicyCheckForStateChanges') || noop;\n\t    self.defaults.stateDefinitions = self.defaults.stateDefinitions || getService('formPolicyStateDefinitions') || nullStateChanges;\n\t\n\t    var policyService = {\n\t      getCurrentPolicy: function getCurrentPolicy() {\n\t        return _angular2.default.copy(self.defaults);\n\t      }\n\t    };\n\t\n\t    return policyService;\n\t  }];\n\t});\n\t\n\tfunction formDirective(formPolicyService) {\n\t\n\t  return {\n\t    //priority: -1,\n\t    restrict: 'AE',\n\t    require: ['?form'], // Tells the directive to get the controller for the 'form' directive, which is the FormController controller\n\t    compile: function compile(tElement, tAttr) {\n\t\n\t      // Use element.data() to store a reference to this element for use by child.inheritedData()\n\t      // Will storing an element this way cause a memory leak? Or should I just store the data I currently need (attr.class)\n\t      // This has to happen during the compile step, as the children need access to the variable when they are compiled\n\t      //  ('class' is a reserved word to JavaScript, so we need to treat it as a string)\n\t      tElement.data('formElementClasses', tAttr['class']); //jscs:ignore\n\t\n\t      return {\n\t        pre: function pre(scope, element, attr, controller) {\n\t          // We want to extend the FormController by adding a form policy\n\t          var formController = controller[0];\n\t          formController._policy = _angular2.default.extend(formPolicyService.getCurrentPolicy(), scope.$eval(attr.formPolicy));\n\t\n\t          // Add a reference to the <form> element's scope to the formController, to support showing errors for nested components\n\t          formController._scope = scope;\n\t\n\t          // Determine if we have a parent form controller. If we do, we want to use it for the focus behaviour\n\t          formController._parentController = element.parent().controller('form');\n\t\n\t          if (!formController._parentController) {\n\t            // We also want to add an element reference when a control is added\n\t            formController._controls = {};\n\t          }\n\t\n\t          // Generate the focus policy function for use by other directive\n\t          formController._applyFormBehaviourOnStateChangePolicy = formController._policy.behaviourOnStateChange(formController);\n\t\n\t          // Add/remove a class onto the form based on the value of the formSubmitted variable\n\t          formController.setSubmitted = function (value, tellNoOne) {\n\t            element[value ? 'addClass' : 'removeClass'](formController._policy.formSubmitAttemptedClass);\n\t            formController._formSubmitAttempted = value;\n\t            formController._applyFormBehaviourOnStateChangePolicy.resetBehaviour();\n\t\n\t            if (value && !tellNoOne) {\n\t              scope.$broadcast('event:FormSubmitAttempted');\n\t            }\n\t          };\n\t\n\t          // Flag to indicate whether the form has been submitted\n\t          formController._formSubmitAttempted = false;\n\t          formController._applyFormBehaviourOnStateChangePolicy.resetBehaviour();\n\t\n\t          // If this form is an ngForm (in that it has a parent 'form'), then we need to make sure that\n\t          // when the parent form is submitted or reset, the same thing happens to the child forms\n\t          if (formController._parentController) {\n\t            scope.$watch(function () {\n\t              return formController._parentController._formSubmitAttempted;\n\t            }, function (value) {\n\t              if (value !== undefined) {\n\t                //formController.setSubmitted(!!value, true);  // Don't send another notification, just update our own state\n\t                formController.setSubmitted(!!value); // Don't send another notification, just update our own state\n\t              }\n\t            });\n\t          }\n\t        }\n\t      };\n\t    }\n\t  };\n\t}\n\tmod.directive('form', ['formPolicyService', formDirective]);\n\tmod.directive('ngForm', ['formPolicyService', formDirective]);\n\t\n\t// We want our formController to expose the list of controls that are registered with the form,\n\t// including controls inside sub-forms. That allows us to reset them directly. Relying simply on the fieldName\n\t// does not work when using sub-forms inside ng-repeaters.\n\t\n\tvar inputElements = ['input', 'select'];\n\t\n\t_angular2.default.forEach(inputElements, function (inputElem) {\n\t  mod.directive(inputElem, function () {\n\t\n\t    function hookupElementToNameToElementMap(formController, element, fieldName, fieldController) {\n\t      // Each element in the map is an array, because form elements *can have the same name*!\n\t      var map = formController._controls;\n\t      if (!map[fieldName]) {\n\t        map[fieldName] = [];\n\t      }\n\t      // Add the field to the end of the list of items with the same name\n\t      map[fieldName][map[fieldName].length] = { 'element': element, 'controller': fieldController };\n\t\n\t      element.on('$destroy', function () {\n\t        // Delete just this element from the map of controls\n\t        var map = formController._controls[element.attr('name')];\n\t        var elementId = element.attr('id');\n\t        for (var i = 0; i < map.length; i++) {\n\t          if (map[i].element.attr('id') === elementId) {\n\t            map.splice(i, 1);\n\t            break;\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    return {\n\t      restrict: 'E',\n\t      require: ['?^form', '?ngModel'],\n\t      link: {\n\t        pre: function pre(scope, element, attr, controllers) {\n\t          if (!controllers[0]) {\n\t            return;\n\t          }\n\t\n\t          var rootFormController = controllers[0]._parentController || controllers[0],\n\t              fieldController = controllers[1],\n\t              name = attr.name;\n\t\n\t          if (rootFormController && rootFormController._controls) {\n\t            hookupElementToNameToElementMap(rootFormController, element, name, fieldController);\n\t          }\n\t        }\n\t      }\n\t    };\n\t  });\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormCheckboxTemplate.tpl.html\";\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormDateInputTemplate.tpl.html\";\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormInputTemplate.tpl.html\";\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormRadioButtonTemplate.tpl.html\";\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/FormSelectTemplate.tpl.html\";\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"/template/RequiredMarkerTemplate.tpl.html\";\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** js/ngFormLib.8d85ed5f.js\n **/","import angular from 'angular';\nimport ngTranslate from 'angular-translate';\n\nconst mod = angular.module('ngFormLib.controls.errorMessageContainer', [ngTranslate]);\n\nexport default mod.name;\n\n\n//angular.module('ngFormLib.controls.errorMessageContainer', ['pascalprecht.translate'])\n\n/**\n * This directive is really a FIELD error message container - it is designed to work with fields exclusively\n */\nmod.directive('errorContainer', ['$compile', '$filter', function($compile, $filter) {\n\n  function translateError(errorMessage, fieldLabel) {\n    var firstLetterIsAVowel = fieldLabel ? ('aeiou'.indexOf(fieldLabel[0].toLowerCase()) !== -1) : undefined;\n    return $filter('translate')(errorMessage, {pronoun: firstLetterIsAVowel ? 'an' : 'a', fieldLabel: fieldLabel});\n  }\n\n  function ErrorController(element) {\n    var errors = [],\n      ariaElement = element;\n\n    return {\n      addError: function(errorType, errorMessage, fieldLabel) {\n        errors[errorType] = translateError(errorMessage, fieldLabel);\n      },\n\n      removeError: function(errorType) {\n        delete errors[errorType];\n      },\n\n      refreshErrorText: function() {\n        var str = '', i = 0;\n        for (var type in errors) {\n          if (errors.hasOwnProperty(type)) {\n            str += 'Error ' + (++i) + ', ' + errors[type] + ',';\n          }\n        }\n\n        if (i === 1) {\n          str = '. There is 1 error for this field. ' + str;\n        } else if (i > 1) {\n          str = '. There are ' + i + ' errors for this field. ' + str;\n        }\n        ariaElement.text(str);\n      }\n    };\n  }\n\n  function generateErrorTag(errorType, errorText, fieldLabel) {\n    return '<div class=\"text-error ec2-' + errorType + '\"><span class=\"text-error-wrap\">' + translateError(errorText, fieldLabel) + '</span></div>';\n  }\n\n  /**\n   * Handle the field-based error messages\n   */\n  function toggleErrorVisibilityOnError(controller, formController, scope, element, watchExpr, errorType, errorText, fieldLabel) {\n    //console.log('watchExpr = ' + watchExpr);\n    formController._scope.$watch(watchExpr, function(newValue) {\n      if (newValue) {\n        // The error text could contain an interpolation string, so we need to compile it\n        var val = $compile(generateErrorTag(errorType, errorText, fieldLabel))(scope);\n        element.append(val);\n        controller.addError(errorType, errorText, fieldLabel);\n      } else {\n        removeErrorMessage(controller, formController, element, errorType);\n      }\n      controller.refreshErrorText();\n    });\n  }\n\n  /**\n   * Handle text errors. Text errors are associated with a scope, rather than with a field.\n   * This means we can clear them from the scope when the field-they-are-associated-with is changed.\n   */\n  function toggleErrorVisibilityForTextError(errorController, formController, fieldController, scope, element, watchExpr, fieldLabel) {\n    //console.log('Watching error: ' + watchExpr);\n\n    formController._scope.$watch(watchExpr, function(newValue) {\n      // Update the validity of the field's \"watchExpr\" error-key to match the value of the errorText\n      fieldController.$setValidity(watchExpr, !newValue);\n\n      // Remove the old error message for this same errorType first, in cases where the error message is changing.\n      removeErrorMessage(errorController, formController, element, watchExpr);\n\n      if (newValue) {\n        // No need to compile the error message as we already have its value\n        element.append(generateErrorTag(watchExpr, newValue, fieldLabel));\n        errorController.addError(watchExpr, newValue, fieldLabel);\n\n        // Turn the border red by sending a 'form-submit-attempted' event\n        formController.setSubmitted(true);\n      }\n      errorController.refreshErrorText();\n    });\n\n    // When the field changes, clear the errorText value\n    fieldController.$viewChangeListeners.push(function() {\n      if (scope.$eval(watchExpr)) {\n        scope.$eval(watchExpr + ' = null');\n      }\n    });\n  }\n\n\n  function removeErrorMessage(controller, formController, element, errorType) {\n    // find the div with our special class, then remove it\n    var divs = element.find('div');\n    for (var len = divs.length, i = len - 1; i > -1; i--) {\n      if (divs.eq(i).hasClass('ec2-' + errorType)) {\n        divs.eq(i).remove();\n      }\n    }\n    controller.removeError(errorType);\n  }\n\n  return {\n    restrict: 'AE',\n    require: ['^form'], // Require the formController controller somewhere in the parent hierarchy (mandatory for field-errors)\n    template: '<div class=\"container-error\"></div>',\n    replace: true,\n    link: function(scope, element, attr, controllers) {\n\n      var fieldName = attr.fieldName,\n        fieldLabel = attr.fieldLabel || '',\n        formController = controllers[0],\n        formName = formController.$name,\n        formField = formName + '.' + fieldName,\n        fieldErrors = scope.$eval(attr.fieldErrors || []),  // You can escape interpolation brackets inside strings by doing  \\{\\{   - wow!\n        textErrors = scope.$eval(attr.textErrors || []);\n\n      element.attr('id', formName + '-' + fieldName + '-errors');\n      element.append('<span class=\"sr-only\" aria-hidden=\"true\" id=\"' + formName + '-' + fieldName + '-errors-aria\"></span>');\n\n      var ariaElement = element.find('span'),\n        errorController = new ErrorController(ariaElement);   // new? Maybe make this the directive's controller instead\n\n      for (var error in fieldErrors) {\n        if (fieldErrors.hasOwnProperty(error)) {\n          var errorShowCondition = formField + '.fieldState === \"error\" && ' + formField + '.$error.' + error;\n          toggleErrorVisibilityOnError(errorController, formController, scope, element, errorShowCondition, error, fieldErrors[error], fieldLabel);\n        }\n      }\n\n      // Watch formController[fieldName] - it may not have loaded yet. When it loads, call the main function.\n      if (textErrors) {\n        //console.log('textErrors: ' + textErrors + ', fieldName = ' + fieldName);\n        var fieldWatcher = scope.$watch(function() {\n          return formController[fieldName];\n        }, function(newValue) {\n          if (newValue) {\n            fieldWatcher(); // Cancel the watcher\n\n            // Do the actual thing you planned to do...\n            for (var item in textErrors) {\n              if (textErrors.hasOwnProperty(item)) {\n                toggleErrorVisibilityForTextError(errorController, formController, formController[fieldName], scope, element, textErrors[item], fieldLabel);\n              }\n            }\n          }\n        });\n      }\n\n      element.removeAttr('error-container').removeAttr('field-name').removeAttr('field-errors').removeAttr('text-errors');\n    }\n  };\n}]);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/errorMessageContainer/ErrorMessageContainer.js\n **/","import angular from 'angular';\nimport FieldErrorController from './FieldErrorController';\nimport FormControlService from './FormControlService';\nimport RequiredMarker from '../requiredMarker/RequiredMarker';\n\nconst mod = angular.module('ngFormLib.controls.common', [\n  FieldErrorController,\n  FormControlService,\n  RequiredMarker\n]);\n\nexport default mod.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/common/index.js\n **/","import angular from 'angular';\nimport Utility from '../../../common/Utility';\n\nconst mod = angular.module('ngFormLib.controls.common.formControlService', [Utility]);\n\nexport default mod.name;\n\n// Workaround for bug #1404\n// https://github.com/angular/angular.js/issues/1404\n// Source: http://plnkr.co/edit/hSMzWC?p=preview\n// Not so great for IE8, but necessary for using radio buttons inside of dynamic forms (ng-repeat)\nmod.config(['$provide', function($provide) {\n  $provide.decorator('ngModelDirective', ['$delegate', function($delegate) {\n    var ngModel = $delegate[0], controller = ngModel.controller;\n    ngModel.controller = ['$scope', '$element', '$attrs', '$injector', function(scope, element, attrs, $injector) {\n      var $interpolate = $injector.get('$interpolate');\n      attrs.$set('name', $interpolate(attrs.name || '')(scope));\n      $injector.invoke(controller, this, {\n        '$scope': scope,\n        '$element': element,\n        '$attrs': attrs\n      });\n    }];\n    return $delegate;\n  }]);\n  $provide.decorator('formDirective', ['$delegate', function($delegate) {\n    var form = $delegate[0], controller = form.controller;\n    form.controller = ['$scope', '$element', '$attrs', '$injector', function(scope, element, attrs, $injector) {\n      var $interpolate = $injector.get('$interpolate');\n      attrs.$set('name', $interpolate(attrs.name || attrs.ngForm || '')(scope));\n      $injector.invoke(controller, this, {\n        '$scope': scope,\n        '$element': element,\n        '$attrs': attrs\n      });\n    }];\n    return $delegate;\n  }]);\n}]);\n\n\n// Shared code for the accessible controls\nmod.provider('formControlService', function() {\n  var self = this,\n      counter = 0;    // Private variable\n\n  //\n  self.defaults = {\n    idPrefix: 'fpFld',\n    templates: {\n      formCheckbox: {\n        template:           require('file?name=/template/[name].[ext]!../formCheckbox/template/FormCheckboxTemplate.tpl.html')\n      },\n      formDate: {\n        template:           require('file?name=/template/[name].[ext]!../formDate/template/FormDateInputTemplate.tpl.html')\n      },\n      formInput: {\n        template:           require('file?name=/template/[name].[ext]!../formInput/template/FormInputTemplate.tpl.html')\n      },\n      formRadioButton: {\n        template:           require('file?name=/template/[name].[ext]!../formRadioButton/template/FormRadioButtonTemplate.tpl.html')\n      },\n      formSelect: {\n        template:           require('file?name=/template/[name].[ext]!../formSelect/template/FormSelectTemplate.tpl.html')\n      },\n      requiredMarker: {\n        template:           require('file?name=/template/[name].[ext]!../requiredMarker/template/RequiredMarkerTemplate.tpl.html')\n      }\n    }\n  };\n\n  this.$get = ['ngFormLibStringUtil', '$interpolate', function(StringUtil) {\n\n    var service = {\n      defaults: self.defaults,\n\n      buildDirective: function(params) {\n        var directive = {\n          restrict: 'AE',\n          replace: true,\n          transclude: true,\n          compile: function(tElement, tAttr) {\n\n            service.validateComponentStructure(params.controlName, tElement, params.expectedTemplateElements, tAttr, params.expectedAttributes);\n\n            // For items that are inside repeaters, if more than one element has the same id, the checkbox stops working.\n            // By using an attribute that is not called 'id', we can avoid this issue\n            var id = tAttr.uid || service.getUniqueFieldId(),\n              name = tAttr.name || id,// Doing this *will* break radio buttons, but they SHOULD provide a name anyway (for their own good)\n              inputElem = tElement.find(params.inputElementName || 'input'),\n              labelElem = tElement.find('label'),\n              required = service.getRequiredAttribute(tAttr.required);\n\n            service.decorateLabel(labelElem, required, id, tAttr.labelClass, tAttr.hideLabel, tAttr.hideRequiredIndicator, tAttr.labelSuffix);\n            inputElem = service.decorateInputField(inputElem, tElement, tAttr, id, name, required);\n\n            // Do component-specific config last\n            params.configFn(tElement, tAttr, id, name, inputElem, labelElem);\n\n            // Clean up special attributes (to make HTML look nicer)\n            tElement.removeAttr('uid').removeAttr('name').removeAttr('label').removeAttr('required').removeAttr('field-hint')\n              .removeAttr('input-type').removeAttr('hide-label').removeAttr('hideRequiredIndicator')\n              .removeAttr('label-class').removeAttr('field-errors').removeAttr('text-errors');\n          },\n          templateUrl: function(element, attr) {\n            // Check the element for a \"template\" attribute, which allows customisation-per-control. Otherwise, use the control-wide template.\n            return attr.template || service.getHTMLTemplate(element, params.controlName);\n          }\n        };\n\n        return directive;\n      },\n\n      getUniqueFieldId: function() {\n        return '' + self.defaults.idPrefix + counter++;\n      },\n\n      getHTMLTemplate: function(element, type) {\n        // Allow different templates to be applied for different form-styles (eg for horizontal forms, inline forms, \"normal\" forms).\n        // This is an advanced feature that most users will not need.\n        // E.g.: self.defaults.templates['select']['form-inline'] = 'path/to/your/custom/template.html'\n\n        // Check this element's parent-form-element-classes to see if they match. First match, wins.\n        var parentFormClasses = (element.inheritedData('formElementClasses') || '').split(' ');\n        var result = self.defaults.templates[type].template;  // The default template, if nothing else is specified.\n\n        for (var i = 0; i < parentFormClasses.length; i++) {\n          var template = self.defaults.templates[type][parentFormClasses[i]];\n          if (template) {\n            result = template;\n            break;\n          }\n        }\n\n        return result;\n      },\n\n      addToAttribute: function(element, attributeName, value) {\n        var existingVal = element.attr(attributeName);\n        element.attr(attributeName, ((existingVal) ? existingVal + ' ' : '') + value);\n      },\n\n\n      removeFromAttribute: function(element, attributeName, value) {\n        // Borrowed this statement from Angular.js\n        var newValue = StringUtil.trim(\n          (' ' + (element.attr(attributeName) || '') + ' ')\n          .replace(/[\\n\\t]/g, ' ')\n          .replace(' ' + StringUtil.trim(value) + ' ', ' ')\n        );\n\n        // Remove the attribute if it is empty\n        if (newValue === '') {\n          element.removeAttr(attributeName);\n        } else {\n          element.attr(attributeName, newValue);\n        }\n      },\n\n\n      getRequiredAttribute: function(required) {\n        // When we set required=\"true\" on a parent directive (like on-off-button), inputElem.attr('required', 'true')\n        // becomes <input required=\"required\" due to browser interference. So detect this case, and replace it with \"true\"\n        // In v1.3, required=\"true\" becomes required=\"\".\n        if (required === 'required' || required === '' || required === 'true') {\n          return 'true';\n        } else if (required === undefined) {\n          return 'false';\n        }\n        return required;\n      },\n\n\n      decorateLabel: function(labelElem, required, id, labelClass, hideLabelExpr, hideRequiredIndicator, labelSuffix) {\n        if (id) {\n          labelElem.attr('for', id);\n        }\n        if (labelClass) {\n          labelElem.addClass(labelClass);\n        }\n        if (hideLabelExpr) {\n          labelElem.attr('ng-class', '{\\'sr-only\\': ' + hideLabelExpr + '}');\n        }\n        if (!hideRequiredIndicator) {\n          labelElem.append('<span required-marker hide=\"!(' + required + ')\"></span>');\n        }\n        // Some labels have suffix text - text that helps with describing the label, but isn't really the label text.\n        // E.g. Amount ($AUD)\n        if (labelSuffix) {\n          labelElem.text(labelElem.text() + ' ' + labelSuffix);\n        }\n      },\n\n\n\n      decorateInputField: function(inputElem, hostElement, attr, id, name, required) {\n        if (attr.inputType) {\n          // inputElem.attr('type', attr.inputType); // THIS WILL NOT WORK ON IE8!\n          // Instead, we must replace the entire node with the only property which SHOULD exist on the template: 'class'\n          inputElem.replaceWith('<input type=\"' + attr.inputType + '\" class=\"' + inputElem.attr('class') + '\">');\n          inputElem = hostElement.find('input');\n        }\n\n        inputElem.attr('id', id);\n\n        // Allow the name to be interpolated\n        inputElem.attr('name', name);\n\n        // Apply all of the ff-* attributes to the input element. Use the original attribute names\n        // attr.$attr contains the snake-case names e.g. 'form-field' vs camel case 'formField'\n        for (var a in attr.$attr) {\n          if (a.indexOf('ff') === 0) {    // Don't search for 'ff-' as the '-' has been replaced with camel case now\n            var origAttrName = attr.$attr[a].substr(3);\n\n            if (origAttrName === 'class') {\n              inputElem.addClass(attr[a]);\n\n            // Special case for type property. It *must* be read-only. Therefore, don't write it to the element\n            // See http://stackoverflow.com/questions/8378563/why-cant-i-change-the-type-of-an-input-element-to-submit\n            } else if (origAttrName !== 'type') {\n              inputElem.attr(origAttrName, attr[a]);\n            }\n\n            // Remove all attributes off the host element\n            hostElement.removeAttr(attr.$attr[a]);\n          }\n        }\n\n        inputElem.attr('ng-required', required);\n        inputElem.attr('aria-required', '{{!!(' + required + ')}}');  // evaluates to true / false\n        return inputElem;\n      },\n\n\n      createErrorFeatures: function(parentElement, inputElement, name, fieldLabel, fieldErrors, textErrors) {\n        if (fieldErrors || textErrors) {\n          // Add an fieldErrorControllers attribute to the element, to hook-up the error features\n          inputElement.attr('field-error-controller', '');\n\n          var fieldLabelStr = (fieldLabel) ? ' field-label=\"' + fieldLabel + '\"' : '';\n          var errorContainerElem = angular.element('<div error-container field-name=\"' + name + '\"' + fieldLabelStr + '></div>');\n          if (fieldErrors) {\n            errorContainerElem.attr('field-errors', fieldErrors);\n          }\n          if (textErrors) {\n            errorContainerElem.attr('text-errors', textErrors);\n          }\n          parentElement.append(errorContainerElem);\n        }\n      },\n\n      createFieldHint: function(hostElement, inputElement, fieldHint, fieldHintId, fieldHintDisplay) {\n        var hintElement;\n\n        if (fieldHint) {\n          // If we have a field hint, add that as well\n          if (fieldHintDisplay) {\n            // If a field hint display rule exists, implement.\n            hintElement = angular.element('<p ng-if=\"' + fieldHintDisplay + '\" class=\"help-block\" id=\"' + fieldHintId + '\">' + fieldHint + '</p>');\n          } else {\n            hintElement = angular.element('<p class=\"help-block\" id=\"' + fieldHintId + '\">' + fieldHint + '</p>');\n          }\n          hostElement.append(hintElement);\n          inputElement.attr('aria-describedby', fieldHintId);\n        }\n      },\n\n      buildNgClassExpression: function(inputElem, targetElem) {\n        // If the inputElem has an ngModel and/or ngChecked attribute, create the ng-class attribute\n        //todo.. test checkbox implementation\n        var modelStr = inputElem.attr('ng-model'),\n            checkedStr = inputElem.attr('ng-checked'),\n            disabledStr = inputElem.attr('ng-disabled'),\n            value = inputElem.attr('value'),        // a string - used for Radio buttons\n            ngValue = inputElem.attr('ng-value'),   // an expression - used for Radio buttons\n            ngTrueValue = inputElem.attr('ng-true-value');\n\n        if (modelStr) {\n          if (ngValue || ngTrueValue) {\n            modelStr += ' === ' + (ngValue || ngTrueValue);\n          } else if (value) {\n            // The value is ALWAYS a string\n            modelStr += ' === \\'' + value + '\\'';\n          } else {\n            modelStr += ' === true';  // For checkboxes, in the absence of ng-true-value\n          }\n        }\n\n        if (modelStr && checkedStr) {\n          modelStr += ' || ' + checkedStr;\n        } else if (checkedStr) {\n          modelStr = checkedStr;\n        }\n\n        if (modelStr && disabledStr) {\n          targetElem.attr('ng-class', '{\\'checked\\': ' + modelStr + ', \\'disabled\\': ' + disabledStr + '}');\n        } else if (modelStr) {\n          targetElem.attr('ng-class', '{\\'checked\\': ' + modelStr + '}');\n        }\n      },\n\n      validateComponentStructure: function(componentName, element, requiredElements, attr, requiredAttributes) {\n        for (var i = 0; i < requiredElements.length; i++) {\n          if (!element.find(requiredElements[i])) {\n            throw new Error('The ' + componentName + ' component template requires a ' + requiredElements[i] + ' element.');\n          }\n        }\n\n        for (var j = 0; j < requiredAttributes.length; j++) {\n          if (!attr[requiredAttributes[j]]) {\n            throw new Error('The ' + componentName + ' component requires a ' + requiredAttributes[j] + ' attribute.');\n          }\n        }\n      }\n\n    };\n    return service;\n  }];\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/common/FormControlService.js\n **/","import angular from 'angular';\n\nconst mod = angular.module('ngFormLib.common.utility', []);\n\nexport default mod.name;\n\nmod.constant('ngFormLibDateUtil', {\n  convertDate: function(dateStr, newSep) {\n    // Converts a date between dd/mm/yyyy and yyyy-mm-dd\n    if (!dateStr || !newSep || !(newSep === '/' || newSep === '-')) {\n      return dateStr;\n    }\n\n    // Choose a separator string that is the 'opposite' of the desired separator\n    var oldSep = (newSep === '/') ? '-' : '/',\n      parts = dateStr.split(oldSep);\n\n    // if we get a dodgy date OR you tried to convert a date that was already in the correct format, return the input\n    if (isNaN(parts.join('')) || parts.length !== 3) {\n      return dateStr;\n    }\n\n    // Swap the year and day parts around\n    return parts[2] + newSep + parts[1] + newSep + parts[0];\n  },\n  formatDay: function(dayOrDate, month, year) {\n    var dd = dayOrDate, mm = month, yyyy = year;\n    if (dayOrDate.getUTCDay) {\n      dd = dayOrDate.getDate();\n      mm = dayOrDate.getMonth() + 1;//January is 0!`\n      yyyy = dayOrDate.getFullYear();\n    }\n    return ((dd < 10) ? '0' + dd : dd) + '/' + ((mm < 10) ? '0' + mm : mm) + '/' + yyyy;\n  },\n  dateAdd: function(dateStr, numDays) {\n    // Return a modified date in ISO format\n    var myDate = this.getDate(dateStr);\n    myDate.setDate(myDate.getDate() + numDays);\n\n    return this.formatDay(myDate);\n  },\n  getToday: function(optionalDate) {\n    return this.formatDay(optionalDate || new Date());\n  },\n  isISODate: function(dateStr) {\n    return (typeof dateStr === 'string' && dateStr.indexOf('-') > 0);\n  },\n  getDate: function(dateStr) {\n    if (!this.isISODate(dateStr)) {\n      dateStr = this.convertDate(dateStr, '-');\n    }\n    return new Date(dateStr);\n  },\n  monthsBetween: function(date1, date2) {\n    return date2.getMonth() - date1.getMonth() + (12 * (date2.getFullYear() - date1.getFullYear()));\n  }\n});\n\n\nmod.constant('ngFormLibStringUtil', (function() {\n  var trimRegExp = /^\\s+|\\s+$/g;\n\n  return {\n    trim: function(text) {\n      if (typeof text === 'string') {\n        return text.replace(trimRegExp, '');\n      }\n      return text;\n    }\n  };\n})());\n\n\nmod.constant('ngFormLibNumberUtil', (function() {\n  var isDigitsRegExp = /^\\d+$/;\n\n  return {\n    isDigits: function(text) {\n      return isDigitsRegExp.test(text);\n    }\n  };\n})());\n\n\nmod.constant('ngFormLibObjectUtil', {\n  getUniqueId: function() {\n    return ('' + (new Date()).getTime() + Math.random()).replace(/\\./, '');\n  },\n  toArray: function(obj) {\n    var arr = [];\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        arr[arr.length] = {key: i, value: obj[i]};\n      }\n    }\n    arr.sort(function compare(a, b) {\n      return a.key < b.key;\n    });\n    return arr;\n  }\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/common/Utility.js\n **/","import angular from 'angular';\nimport FormControlService from './FormControlService';\n\nconst mod = angular.module('ngFormLib.controls.common.fieldErrorController', [\n  FormControlService\n]);\n\nexport default mod.name;\n\n/**\n * The Field Error Controller directive is designed to indicate to the browser when the field is in error\n *  and what the errors are. It applies the form-policy for showing errors\n *\n * It works in tandem with the form controller (and FormPolicy.js) to identify when a form-element has an error, and decorates\n *  the element accordingly.\n *\n * It also toggles the fieldController.fieldState flag, based on the form policy provided\n *\n */\n\n// INPUT:\n//  <input ... field-error-controller></input>\n\n// OUTPUT:\n//  <input ... aria-invalid=\"false/true\" aria-describedby=\"fieldId-errors\">\n\n\nmod.directive('fieldErrorController', ['formControlService', '$timeout', function(formControlService, $timeout) {\n\n  function updateAriaFeatures(fieldState, element, formName, fieldName) {\n    element.attr('aria-invalid', fieldState === 'error');\n    var errorElemId = formName + '-' + fieldName + '-errors-aria';\n\n    if (fieldState === 'error') {\n      // Use the errorContainer's special ARIA element as the source of the error text\n      formControlService.addToAttribute(element, 'aria-describedby', errorElemId);\n    } else {\n      formControlService.removeFromAttribute(element, 'aria-describedby', errorElemId);\n    }\n  }\n\n  function updateElementStyle(fieldState, element, formPolicy) {\n    element[(fieldState === 'error') ? 'addClass' : 'removeClass'](formPolicy.fieldErrorClass);\n    element[(fieldState === 'success') ? 'addClass' : 'removeClass'](formPolicy.fieldSuccessClass);\n  }\n\n  function setupCanShowErrorPropertyOnNgModelController(scope, formController, ngModelController, element, name) {\n    // Using the form policy, determine when to show errors for this field\n    var formPolicy = formController._policy,\n      formName = formController.$name,\n      fieldName = formName + '.' + name,\n      stateConditions = formPolicy.stateDefinitions(formName, fieldName);\n\n    formPolicy.checkForStateChanges(formController._scope, element, name, stateConditions, ngModelController, formController);\n  }\n\n\n  return {\n    restrict: 'AE',\n    require: ['?ngModel', '?^form', '?^formGroup'],  // Require the formController controller somewhere in the parent hierarchy\n    replace: true,\n    link: function(scope, element, attr, controllers) {\n      // Tried to use a template string, but the model was not binding properly. Using $compile() works :)\n      var ngModelController = controllers[0],\n        formController = controllers[1],\n        formGroupElement = (controllers[2] || {}).$element || element,// This looks for a parent directive called formGroup, which has a controller, which has an $element property\n        name = attr.name;\n\n\n      if (formController) {\n        var formName = formController.$name,\n          errorBehaviour = formController._applyFormBehaviourOnStateChangePolicy; // returns a function which encapsulates the form policy rules for the behaviour to apply when errors show\n\n        if (ngModelController) {\n          setupCanShowErrorPropertyOnNgModelController(scope, formController, ngModelController, element, name);\n        }\n\n        // When the error-showing flag changes, update the field style\n        formController._scope.$watch(formName + '.' + name + '.fieldState', function(fieldState) {\n          updateAriaFeatures(fieldState, element, formName, name);\n          updateElementStyle(fieldState, formGroupElement, formController._policy);\n\n          // Apply the error behaviour behaviour\n          errorBehaviour.applyBehaviour(element, fieldState, false);\n        });\n\n        // Listen to form-submit events, to determine what to focus on too\n        scope.$on('event:FormSubmitAttempted', function() {\n          // Make sure that the field-level watchers have a chance to fire first, so use a timeout\n          $timeout(function() {\n            errorBehaviour.applyBehaviour(element, ngModelController.fieldState, true);\n          }, 1);\n        });\n      }\n    }\n  };\n}]);\n\n\n// This directive\nmod.directive('formGroup', [function() {\n  return {\n    restrict: 'AC',\n    controller: ['$scope', '$element', function($scope, $element) {\n      this.$element = $element;\n    }]\n  };\n}]);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/common/FieldErrorController.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common/index';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formCheckbox', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n\n// INPUT:\n//  <form-checkbox id=\"id\" name=\"name\" required=\"{{expression}}\"\n//      ff-class=\"span12\" ff-ng-model=\"application.contentType\" ff-value=\"software\" ff-aria-label=\"Software\"\n//        ff-ng-click=\"doSomething()\"\n//      field-errors=\"{required: 'Please select'}\"\n//      text-errors=\"['wrong value']\"\n//      >My label with <a href=\"http://www.google.com/\">HTML bits</a> in it</form-checkbox>\n\n// OUTPUT:\n\n\nmod.directive('formCheckbox', ['formControlService', function(formControlService) {\n\n  return formControlService.buildDirective({\n    controlName: 'formCheckbox',\n    expectedTemplateElements: ['input', 'label', 'div'],\n    expectedAttributes: [],\n    configFn: function(tElement, tAttr, id, name, inputElem) {\n      // Move the class attribute from the outer-DIV to the checkbox DIV (special case)\n      var checkboxDiv = tElement.find('div');\n      checkboxDiv.addClass(tElement.attr('class'));\n      tElement.removeAttr('class');\n\n      formControlService.createErrorFeatures(tElement, inputElem, name, '', tAttr.fieldErrors, tAttr.textErrors);\n      formControlService.buildNgClassExpression(inputElem, inputElem);  // Put the ng-class onto the input element itself, as this makes styling easier\n    }\n  });\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formCheckbox/FormCheckbox.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formDate', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n\n// INPUT:\n//    <div form-date id=\"toDate\" name=\"toDate\" label=\"To date\" hide-label=\"true\" input-type=\"text\"\n//    ff-ng-model=\"acctCtrl.search.toDate\" ff-max-date=\"today\" ff-bs-show=\"acctCtrl.datePickers.datePickerTo\"\n//    ff-ng-blur=\"acctCtrl.toggleDatePicker('datePickerTo', true)\"\n//    ff-ng-focus=\"acctCtrl.toggleDatePicker('datePickerFrom', true)\"\n//    ff-class=\"form-control input-beta input-date\"\n//    field-errors=\"{date: 'ERROR.DATE_INVALID'}\" >\n//      <i class=\"calendar\" ng-click=\"acctCtrl.toggleDatePicker('datePickerTo')\"></i>\n//    </div>\n\n\nmod.directive('formDate', ['formControlService', function(formControlService) {\n\n  return formControlService.buildDirective({\n    controlName: 'formDate',\n    expectedTemplateElements: ['input', 'label'],\n    expectedAttributes: ['label'],\n    configFn: function(tElement, tAttr, id, name, inputElem, labelElem) {\n      labelElem.prepend(tAttr.label);\n\n      //formControlService.decorateInputGroup(tElement.find('div'), tAttr.inputGroupClass);\n      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n      formControlService.createErrorFeatures(inputElem.parent(), inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n    }\n  });\n}]);\n\n\nmod.directive('formDateFormat', ['ngFormLibDateUtil', function(DateUtil) {\n  // All dates greater than AD 0 and less than AD 10000 in dd/mm/yyyy format\n  // RegEx behaves oddly if /g is uses in Regexp.test() situations\n  var dateRegEx = /^(((0[1-9]|[12][0-9]|3[01])([\\/])(0[13578]|10|12)([\\/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([\\/])(0[469]|11)([\\/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([\\/])(02)([\\/])(\\d{4}))|((29)(\\/)(02)([\\/])([02468][048]00))|((29)([\\/])(02)([\\/])([13579][26]00))|((29)([\\/])(02)([\\/])([0-9][0-9][0][48]))|((29)([\\/])(02)([\\/])([0-9][0-9][2468][048]))|((29)([\\/])(02)([\\/])([0-9][0-9][13579][26])))$/;\n\n  return {\n    require: 'ngModel',\n    priority: 150,    // Higher priority than ui-mask (100), so the postLink function runs last\n    link: function(scope, elem, attrs, ctrl) {\n\n\n      ctrl.$parsers.unshift(function(viewValue) {\n\n\n        // If viewValue is undefined or null, jump out\n        if (!viewValue) {\n          ctrl.$setValidity('date', true);\n          ctrl.$setValidity('minDate', true);  // Turn off the error if the date format isn't valid\n          ctrl.$setValidity('maxDate', true);  // Turn off the error if the date format isn't valid\n          return viewValue;\n        }\n\n        // If viewValue is a string of 8 digits, then convert it to dd/dd/dddd first\n        if (viewValue.length === 8 && !isNaN(viewValue * 1)) {\n          viewValue = viewValue.substr(0, 2) + '/' + viewValue.substr(2, 2) + '/' + viewValue.substr(4);\n        }\n\n        // Check that it is a valid date\n        var dateFormatValid = dateRegEx.test(viewValue) || typeof viewValue === 'undefined' || !viewValue;\n        ctrl.$setValidity('date', dateFormatValid);\n\n        //console.log('dateInput: ' + viewValue + ', ' + ctrl.$modelValue);\n\n        // If the date is valid\n        if (dateFormatValid && viewValue) {\n          var fieldDate = DateUtil.getDate(viewValue);\n          // and there is a min date, check if the value is greater than the min date\n          if (attrs.minDate) {\n            var minDate = DateUtil.getDate(attrs.minDate);\n            ctrl.$setValidity('minDate', fieldDate.getTime() >= minDate.getTime());\n          } else {\n            ctrl.$setValidity('minDate', true);\n          }\n          // and there is a max date, check if the value is less than the max date\n          if (attrs.maxDate) {\n            var maxDate;\n\n            if (attrs.maxDate === 'today') {\n              maxDate = DateUtil.getDate(DateUtil.getToday());\n            } else {\n              maxDate = DateUtil.getDate(attrs.maxDate);\n            }\n\n            ctrl.$setValidity('maxDate', fieldDate.getTime() <= maxDate.getTime());\n          } else {\n            ctrl.$setValidity('maxDate', true);\n          }\n        } else {\n          ctrl.$setValidity('minDate', true);  // Turn off the error if the date format isn't valid\n          ctrl.$setValidity('maxDate', true);  // Turn off the error if the date format isn't valid\n        }\n        return viewValue;\n      });\n\n      ctrl.$viewChangeListeners.push(function() {\n        // If there is a date-change attribute, execute it when the control is valid\n        if (attrs.dateChange && ctrl.$valid) {\n          scope.$eval(attrs.dateChange);\n        }\n      });\n    }\n  };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formDate/FormDate.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formInput', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n\n// INPUT:\n//  <form-input id=\"\" name=\"\" label=\"Last name\" required=\"{{expression}}\"\n//      ff-class=\"span12\" input-type=\"text|tel|email\" ff-ng-model=\"application.lastName\"\n//      ff-maxlength=\"40\" ff-ng-pattern=\"/^[a-zA-Z0-9 \\-.']+$/\"\n//      field-hint=\"This must be the last name of the person who originally applied for the service.\"\n//      field-errors=\"{required: 'Please enter a valid last name', pattern: 'Please enter a valid last name'}\"\n//      text-errors=\"['data.errors.']\"\n//      content-class=\"span3\"\n//      >My content</form-input>\n\n// OUTPUT:\n\n\nmod.directive('formInput', ['formControlService', function(formControlService) {\n\n  return formControlService.buildDirective({\n    controlName: 'formInput',\n    expectedTemplateElements: ['input', 'label'],\n    expectedAttributes: ['label', 'inputType'],\n    configFn: function(tElement, tAttr, id, name, inputElem, labelElem) {\n      labelElem.prepend(tAttr.label);\n      addPlaceholder(inputElem, tAttr.placeholder); // Do this to be API-compatible with the form-select control. ff-placeholder is still supported. Use one or the other.\n\n      // If the user wants to use 'input-addon-prefix' or 'input-addon-suffix', change the DOM\n      var hasInputGroup = addInputGroup(inputElem, tAttr.inputPrefix, tAttr.inputSuffix);\n      var parentElemForErrors = (hasInputGroup) ? inputElem.parent().parent() : inputElem.parent();\n\n      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n      formControlService.createErrorFeatures(parentElemForErrors, inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n    }\n  });\n}]);\n\n\nfunction addPlaceholder(inputElem, placeholderText) {\n  if (placeholderText) {\n    inputElem.attr('placeholder', placeholderText);\n  }\n}\n\n\nfunction addInputGroup(inputElem, inputGroupPrefix, inputGroupSuffix) {\n  if (inputGroupPrefix || inputGroupSuffix) {\n    inputElem.wrap('<div class=\"input-group\">');//inputElem.parent(); // This should be the 'control-row' element//wrap('<div class=\"input-group\">');\n    var wrapper = inputElem.parent();\n\n    if (inputGroupPrefix) {\n      wrapper.prepend('<span class=\"input-group-addon\">' + inputGroupPrefix + '</span>');\n    }\n    if (inputGroupSuffix) {\n      wrapper.append('<span class=\"input-group-addon\">' + inputGroupSuffix + '</span>');\n    }\n    return true;\n  }\n  return false;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formInput/FormInput.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formRadioButton', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n\n// INPUT:\n//  <form-radio-button uid=\"fld\" name=\"name\" aria-label=\"Book Type\" label-class=\"btn btn-toggle\"\n//    ff-class=\"someCSS\" ff-ng-model=\"application.bookType\" ff-value=\"Fiction\" ng-click=\"loadFiction()\" class=\"span6\">\n//     <icon class=\"icon-fiction\"></icon>Fiction\n//  </form-radio-button>\n\n// OUTPUT:\n\n\nmod.directive('formRadioButton', ['formControlService', function(formControlService) {\n\n  return formControlService.buildDirective({\n    controlName: 'formRadioButton',\n    expectedTemplateElements: ['input', 'label', 'div'],\n    expectedAttributes: [], // The template should NOT have a form-group element inside it, as this has to be specified externally (due to the group-nature of radio buttons)\n    configFn: function(tElement, tAttr, id, name, inputElem) {\n      // Move the class attribute from the outer-DIV to the radio-button DIV (special case)\n      var rbDiv = tElement.find('div');\n      rbDiv.addClass(tElement.attr('class'));\n      tElement.removeAttr('class');\n\n      formControlService.createErrorFeatures(tElement, inputElem, name, '', tAttr.fieldErrors, tAttr.textErrors);\n      formControlService.buildNgClassExpression(inputElem, inputElem);  // Put the ng-class onto the input element itself, as this makes styling easier\n    }\n  });\n\n}]);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formRadioButton/FormRadioButton.js\n **/","import angular from 'angular';\n\nconst mod = angular.module('ngFormLib.controls.formReset', []);\n\nexport default mod.name;\n\n\nmod.directive('formReset', ['$parse', function($parse) {\n\n  function resetFieldState(controlMap) {\n    // Loops through the controlMap and reset's each field's state\n    for (var item in controlMap) {\n      if (controlMap.hasOwnProperty(item)) {\n        var controlList = controlMap[item];\n        for (var j = 0, jLen = controlList.length; j < jLen; j++) {\n          var control = controlList[j].controller;\n          control.fieldState = '';\n        }\n      }\n    }\n  }\n\n\n  return {\n    restrict: 'A',\n    require: '^form',\n    link: function(scope, element, attr, controller) {\n      var ngModelGet = $parse(attr.formReset),\n          ngModelSet = ngModelGet.assign;\n\n      if (!ngModelSet) {\n        throw Error('formReset requires an assignable scope-expression. \"' + attr.formReset + '\" is un-assignable.');\n      }\n\n      // Get a copy of the data as soon as the directive is created, which is after the scope/controller has been initialised (safe)\n      var originalData = angular.copy(ngModelGet(scope));\n\n      element.on('click', function() {\n        if (typeof controller.setSubmitted === 'function') {\n          controller.setSubmitted(false);\n        }\n        // Use a *copy* of the original data, as we don't want originalData to be modified by subsequent changes to the model by the form controls\n        ngModelSet(scope, angular.copy(originalData));\n        resetFieldState(controller._controls || {});\n        controller.$setPristine();\n\n        scope.$emit('event:FormReset');\n        scope.$digest();\n      });\n    }\n  };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formReset/FormReset.js\n **/","import angular from 'angular';\nimport FormLibCommon from '../common';\nimport ErrorMessageContainer from '../errorMessageContainer/ErrorMessageContainer';\n\nconst mod = angular.module('ngFormLib.controls.formSelect', [FormLibCommon, ErrorMessageContainer]);\n\nexport default mod.name;\n\n// INPUT:\n//  <form-select id=\"frm-size\" name=\"bookSize\" required=\"true\" label=\"Approximate size\"\n//    ff-class=\"span12\" ff-ng-model=\"model.size\" placeholder=\"Select a size bracket\"\n//    ff-ng-options=\"option.value as option.name for option in refData.bookSizes\"\n//    field-errors=\"{required: 'Please select a size bracket'}\"\n//    text-errors=\"['data.errors']\"></form-select>\n\n// OUTPUT:\n\n\n\nmod.directive('formSelect', ['formControlService', function(formControlService) {\n\n  function addPlaceholder(selectElem, placeholderText) {\n    if (placeholderText) {\n      selectElem.append('<option translate value=\"\">' + placeholderText + '</option>');\n    }\n  }\n\n  return formControlService.buildDirective({\n    controlName: 'formSelect',\n    inputElementName: 'select',\n    expectedTemplateElements: ['select', 'label'],\n    expectedAttributes: ['label'],\n    configFn: function(tElement, tAttr, id, name, inputElem, labelElem) {\n      labelElem.prepend(tAttr.label);\n      addPlaceholder(inputElem, tAttr.placeholder);  // Adds the extra option element to the start of the <option>\n\n      formControlService.createFieldHint(tElement, inputElem, tAttr.fieldHint, id + '-hint', tAttr.fieldHintDisplay);\n      formControlService.createErrorFeatures(inputElem.parent(), inputElem, name, tAttr.label, tAttr.fieldErrors, tAttr.textErrors);\n    }\n  });\n\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formSelect/FormSelect.js\n **/","import angular from 'angular';\n\nconst mod = angular.module('ngFormLib.controls.formSubmit', []);\n\nexport default mod.name;\n\n\n/**\n *  formSubmit - Executes an expression when the form is valid (essentially a form.submit() handler).\n *\n *  It can be applied to either the form element or to a button.\n *\n */\nmod.directive('formSubmit', ['$parse', function($parse) {\n  return {\n    restrict: 'A',\n    require: ['^form'],   // Get the form controller\n    link: function(scope, element, attr, controller) {\n\n      var fn = $parse(attr.formSubmit) || angular.noop,\n        isForm = element[0].tagName === 'FORM',\n        formController = controller[0];\n\n      element.bind(isForm ? 'submit' : 'click', function(event) {\n\n        formController.setSubmitted(true);\n\n        scope.$apply(function() {\n          //scope.$emit('event:FormSubmitAttempted');\n\n          if (formController.$valid) {\n            if (fn(scope, {$event: event}) !== false) {\n              // Needed by the tracking tool as it clears the input data after a submission.\n              // Potentially, form field validation to be done here, but unnecessary at the moment.\n              // The reset behaviour can be over-ridden by returning false from the called function(maybe prevent default aswell?)\n              formController.setSubmitted(false);\n              formController.$setPristine();\n            }\n\n          } else {\n            event.preventDefault();\n          }\n        });\n      });\n    }\n  };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/formSubmit/FormSubmit.js\n **/","import angular from 'angular';\nimport ErrorMessageContainer from './errorMessageContainer/ErrorMessageContainer';\nimport FormCheckbox from './formCheckbox/FormCheckbox';\nimport FormDate from './formDate/FormDate';\nimport FormInput from './formInput/FormInput';\nimport FormRadioButton from './formRadioButton/FormRadioButton';\nimport FormReset from './formReset/FormReset';\nimport FormSelect from './formSelect/FormSelect';\nimport FormSubmit from './formSubmit/FormSubmit';\n\n  // We need the utility module for the ngFormLibDateUtil.getDate() method for the formDateFormat directive, and ngFormLibStringUtil.trim() in controls.common\nconst mod = angular.module('ngFormLib.controls', [\n  ErrorMessageContainer,\n  FormCheckbox,\n  FormDate,\n  FormInput,\n  FormRadioButton,\n  FormReset,\n  FormSelect,\n  FormSubmit\n]);\n\nexport default mod.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/index.js\n **/","import angular from 'angular';\nimport FormControlService from '../common/FormControlService';\n\nconst mod = angular.module('ngFormLib.controls.requiredMarker', [FormControlService]);\n\nexport default mod.name;\n\n\n// Add a simple \"required\" marker that is not read-out by screen readers (as the field should also have a required indicator)\n//\n// INPUT:\n//  <span required-marker></span>\n//  <span required-marker hide=\"isNotRequired\">Some Text</span>\n\n// OUTPUT:\n//  <span class=\"required\" aria-hidden=\"true\" ng-class=\"{\\'ng-hide\\': hide}\" ng-transclude=\"\"></span>\n//  <span class=\"required\" aria-hidden=\"true\" ng-class=\"{\\'ng-hide\\': hide}\" ng-transclude=\"\" hide=\"isNotRequired\">Some Text</span>\n\nmod.directive('requiredMarker', ['formControlService', function(formControlService) {\n\n  return {\n    restrict: 'AE',\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attr) {\n      return attr.template || formControlService.getHTMLTemplate(element, 'requiredMarker');\n    },\n    scope: {\n      hide: '='\n    }\n  };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/controls/requiredMarker/RequiredMarker.js\n **/","import angular from 'angular';\nimport angularAnimate from 'angular-animate';\nimport FormPolicy from './policy/FormPolicy';\nimport FormControls from './controls';\n\nconst mod = angular.module('ngFormLib', [angularAnimate,\n  FormPolicy,\n//    Add the policies you want, or define your own:\n//    'ngFormLib.policy.checkForStateChanges',\n//    'ngFormLib.policy.displayError',\n//    'ngFormLib.policy.focusBehaviour',\n  FormControls\n]);\n\nexport default mod.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/index.js\n **/","import angular from 'angular';\n\n// The form policy intentionally has no hard dependencies.\n// If there are form-policy values that exist when the service is being constructed, it will use them.\n// Otherwise it will use no-op policy functions.\nconst mod = angular.module('ngFormLib.policy', []);\n\nexport default mod.name;\n\n\n// This is a configurable service\n// It should contain the _default_ values for form policies\n\nmod.provider('formPolicyService', function() {\n  var self = this,\n    noop = angular.noop,\n    nullBehaviourOnStateChange = function() {\n      return {\n        applyBehaviour: noop,\n        resetBehaviour: noop\n      };\n    },\n    nullStateChanges = function() {\n      return {};\n    };\n\n  self.defaults = {\n    formSubmitAttemptedClass: 'form-submit-attempted',\n    fieldErrorClass: 'has-error',\n    fieldSuccessClass: 'has-success',\n    behaviourOnStateChange: null,    // Previously called focusBehavior\n    checkForStateChanges: null,\n    stateDefinitions: null,\n    fieldFocusScrollOffset: 0\n  };\n\n  this.$get = ['$injector', function($injector) {\n\n    function getService(name) {\n      try {\n        return $injector.get(name);\n      } catch (e) {\n        return null;    // Provider-not-found error, ignore and move on\n      }\n    }\n\n    // Policy precedence: this.defaults, policy-value-object, noop\n    self.defaults.behaviourOnStateChange = self.defaults.behaviourOnStateChange || getService('formPolicyBehaviourOnStateChange') || nullBehaviourOnStateChange;\n    self.defaults.checkForStateChanges = self.defaults.checkForStateChanges || getService('formPolicyCheckForStateChanges') || noop;\n    self.defaults.stateDefinitions = self.defaults.stateDefinitions || getService('formPolicyStateDefinitions') || nullStateChanges;\n\n    var policyService = {\n      getCurrentPolicy: function() {\n        return angular.copy(self.defaults);\n      }\n    };\n\n    return policyService;\n  }];\n});\n\n\nfunction formDirective(formPolicyService) {\n\n  return {\n    //priority: -1,\n    restrict: 'AE',\n    require: ['?form'], // Tells the directive to get the controller for the 'form' directive, which is the FormController controller\n    compile: function(tElement, tAttr) {\n\n      // Use element.data() to store a reference to this element for use by child.inheritedData()\n      // Will storing an element this way cause a memory leak? Or should I just store the data I currently need (attr.class)\n      // This has to happen during the compile step, as the children need access to the variable when they are compiled\n      //  ('class' is a reserved word to JavaScript, so we need to treat it as a string)\n      tElement.data('formElementClasses', tAttr['class']);  //jscs:ignore\n\n      return {\n        pre: function(scope, element, attr, controller) {\n          // We want to extend the FormController by adding a form policy\n          var formController = controller[0];\n          formController._policy = angular.extend(formPolicyService.getCurrentPolicy(), scope.$eval(attr.formPolicy));\n\n          // Add a reference to the <form> element's scope to the formController, to support showing errors for nested components\n          formController._scope = scope;\n\n          // Determine if we have a parent form controller. If we do, we want to use it for the focus behaviour\n          formController._parentController = element.parent().controller('form');\n\n          if (!formController._parentController) {\n            // We also want to add an element reference when a control is added\n            formController._controls = {};\n          }\n\n          // Generate the focus policy function for use by other directive\n          formController._applyFormBehaviourOnStateChangePolicy = formController._policy.behaviourOnStateChange(formController);\n\n          // Add/remove a class onto the form based on the value of the formSubmitted variable\n          formController.setSubmitted = function(value, tellNoOne) {\n            element[value ? 'addClass' : 'removeClass'](formController._policy.formSubmitAttemptedClass);\n            formController._formSubmitAttempted = value;\n            formController._applyFormBehaviourOnStateChangePolicy.resetBehaviour();\n\n            if (value && !tellNoOne) {\n              scope.$broadcast('event:FormSubmitAttempted');\n            }\n          };\n\n          // Flag to indicate whether the form has been submitted\n          formController._formSubmitAttempted = false;\n          formController._applyFormBehaviourOnStateChangePolicy.resetBehaviour();\n\n          // If this form is an ngForm (in that it has a parent 'form'), then we need to make sure that\n          // when the parent form is submitted or reset, the same thing happens to the child forms\n          if (formController._parentController) {\n            scope.$watch(function() { return formController._parentController._formSubmitAttempted; }, function(value) {\n              if (value !== undefined) {\n                //formController.setSubmitted(!!value, true);  // Don't send another notification, just update our own state\n                formController.setSubmitted(!!value);  // Don't send another notification, just update our own state\n              }\n            });\n          }\n        }\n      };\n    }\n  };\n}\nmod.directive('form', ['formPolicyService', formDirective]);\nmod.directive('ngForm', ['formPolicyService', formDirective]);\n\n\n// We want our formController to expose the list of controls that are registered with the form,\n// including controls inside sub-forms. That allows us to reset them directly. Relying simply on the fieldName\n// does not work when using sub-forms inside ng-repeaters.\n\nvar inputElements = ['input', 'select'];\n\nangular.forEach(inputElements, function(inputElem) {\n  mod.directive(inputElem, function() {\n\n    function hookupElementToNameToElementMap(formController, element, fieldName, fieldController) {\n      // Each element in the map is an array, because form elements *can have the same name*!\n      var map = formController._controls;\n      if (!map[fieldName]) {\n        map[fieldName] = [];\n      }\n      // Add the field to the end of the list of items with the same name\n      map[fieldName][map[fieldName].length] = {'element': element, 'controller': fieldController};\n\n\n      element.on('$destroy', function() {\n        // Delete just this element from the map of controls\n        var map = formController._controls[element.attr('name')];\n        var elementId = element.attr('id');\n        for (var i = 0; i < map.length; i++) {\n          if (map[i].element.attr('id') === elementId) {\n            map.splice(i, 1);\n            break;\n          }\n        }\n      });\n    }\n\n    return {\n      restrict: 'E',\n      require: ['?^form', '?ngModel'],\n      link: {\n        pre: function(scope, element, attr, controllers) {\n          if (!controllers[0]) {\n            return;\n          }\n\n          var rootFormController = controllers[0]._parentController || controllers[0],\n              fieldController = controllers[1],\n              name = attr.name;\n\n          if (rootFormController && rootFormController._controls) {\n            hookupElementToNameToElementMap(rootFormController, element, name, fieldController);\n          }\n        }\n      }\n    };\n  });\n});\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./modules/ngFormLib/policy/FormPolicy.js\n **/","module.exports = __webpack_public_path__ + \"/template/FormCheckboxTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formCheckbox/template/FormCheckboxTemplate.tpl.html\n ** module id = 20\n ** module chunks = 1 2\n **/","module.exports = __webpack_public_path__ + \"/template/FormDateInputTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formDate/template/FormDateInputTemplate.tpl.html\n ** module id = 21\n ** module chunks = 1 2\n **/","module.exports = __webpack_public_path__ + \"/template/FormInputTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formInput/template/FormInputTemplate.tpl.html\n ** module id = 22\n ** module chunks = 1 2\n **/","module.exports = __webpack_public_path__ + \"/template/FormRadioButtonTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formRadioButton/template/FormRadioButtonTemplate.tpl.html\n ** module id = 23\n ** module chunks = 1 2\n **/","module.exports = __webpack_public_path__ + \"/template/FormSelectTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/formSelect/template/FormSelectTemplate.tpl.html\n ** module id = 24\n ** module chunks = 1 2\n **/","module.exports = __webpack_public_path__ + \"/template/RequiredMarkerTemplate.tpl.html\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/file-loader?name=/template/[name].[ext]!./modules/ngFormLib/controls/requiredMarker/template/RequiredMarkerTemplate.tpl.html\n ** module id = 25\n ** module chunks = 1 2\n **/"],"sourceRoot":""}